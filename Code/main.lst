CCS PCH C Compiler, Version 5.025, 12584               04-sep.-19 23:19

               Filename:   C:\Users\resen\SmartCane\Code\main.lst

               ROM used:   6770 bytes (21%)
                           Largest free fragment is 25994
               RAM used:   614 (30%) at main() level
                           683 (33%) worst case
               Stack used: 3 locations (2 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   19C2
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   00BA
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   0184
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include <18F2553.h> 
.................... //////////// Standard Header file for the PIC18F2553 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F2553 
*
019C:  DATA 41,54
019E:  DATA 2B,43
01A0:  DATA 4D,47
01A2:  DATA 46,3D
01A4:  DATA 31,0D
01A6:  DATA 00,00
01A8:  DATA 41,54
01AA:  DATA 2B,43
01AC:  DATA 4D,47
01AE:  DATA 53,3D
01B0:  DATA 22,2B
01B2:  DATA 35,32
01B4:  DATA 25,2E
01B6:  DATA 30,66
01B8:  DATA 25,2E
01BA:  DATA 30,66
01BC:  DATA 22,0D
01BE:  DATA 00,00
01C0:  DATA 68,74
01C2:  DATA 74,70
01C4:  DATA 73,3A
01C6:  DATA 2F,2F
01C8:  DATA 6D,61
01CA:  DATA 70,73
01CC:  DATA 2E,67
01CE:  DATA 6F,6F
01D0:  DATA 67,6C
01D2:  DATA 65,2E
01D4:  DATA 63,6F
01D6:  DATA 6D,2F
01D8:  DATA 3F,71
01DA:  DATA 3D,25
01DC:  DATA 2E,36
01DE:  DATA 66,2C
01E0:  DATA 2D,25
01E2:  DATA 2E,36
01E4:  DATA 66,1A
01E6:  DATA 0D,00
*
02EA:  MOVLW  8E
02EC:  MOVWF  00
02EE:  MOVFF  298,01
02F2:  MOVFF  297,02
02F6:  CLRF   03
02F8:  MOVF   01,F
02FA:  BNZ   030E
02FC:  MOVFF  02,01
0300:  CLRF   02
0302:  MOVLW  08
0304:  SUBWF  00,F
0306:  MOVF   01,F
0308:  BNZ   030E
030A:  CLRF   00
030C:  BRA    031E
030E:  BCF    FD8.0
0310:  BTFSC  01.7
0312:  BRA    031C
0314:  RLCF   02,F
0316:  RLCF   01,F
0318:  DECF   00,F
031A:  BRA    030E
031C:  BCF    01.7
031E:  RETURN 0
0320:  MOVLB  2
0322:  MOVF   x95,W
0324:  BTFSC  FD8.2
0326:  BRA    040A
0328:  MOVWF  00
032A:  MOVF   x99,W
032C:  BTFSC  FD8.2
032E:  BRA    040A
0330:  ADDWF  00,F
0332:  BNC   033C
0334:  MOVLW  81
0336:  ADDWF  00,F
0338:  BC    040A
033A:  BRA    0344
033C:  MOVLW  7F
033E:  SUBWF  00,F
0340:  BNC   040A
0342:  BZ    040A
0344:  MOVFF  296,29D
0348:  MOVF   x9A,W
034A:  XORWF  x9D,F
034C:  BSF    x96.7
034E:  BSF    x9A.7
0350:  MOVF   x98,W
0352:  MULWF  x9C
0354:  MOVFF  FF4,29F
0358:  MOVF   x97,W
035A:  MULWF  x9B
035C:  MOVFF  FF4,03
0360:  MOVFF  FF3,29E
0364:  MULWF  x9C
0366:  MOVF   FF3,W
0368:  ADDWF  x9F,F
036A:  MOVF   FF4,W
036C:  ADDWFC x9E,F
036E:  MOVLW  00
0370:  ADDWFC 03,F
0372:  MOVF   x98,W
0374:  MULWF  x9B
0376:  MOVF   FF3,W
0378:  ADDWF  x9F,F
037A:  MOVF   FF4,W
037C:  ADDWFC x9E,F
037E:  MOVLW  00
0380:  CLRF   02
0382:  ADDWFC 03,F
0384:  ADDWFC 02,F
0386:  MOVF   x96,W
0388:  MULWF  x9C
038A:  MOVF   FF3,W
038C:  ADDWF  x9E,F
038E:  MOVF   FF4,W
0390:  ADDWFC 03,F
0392:  MOVLW  00
0394:  ADDWFC 02,F
0396:  MOVF   x96,W
0398:  MULWF  x9B
039A:  MOVF   FF3,W
039C:  ADDWF  03,F
039E:  MOVF   FF4,W
03A0:  ADDWFC 02,F
03A2:  MOVLW  00
03A4:  CLRF   01
03A6:  ADDWFC 01,F
03A8:  MOVF   x98,W
03AA:  MULWF  x9A
03AC:  MOVF   FF3,W
03AE:  ADDWF  x9E,F
03B0:  MOVF   FF4,W
03B2:  ADDWFC 03,F
03B4:  MOVLW  00
03B6:  ADDWFC 02,F
03B8:  ADDWFC 01,F
03BA:  MOVF   x97,W
03BC:  MULWF  x9A
03BE:  MOVF   FF3,W
03C0:  ADDWF  03,F
03C2:  MOVF   FF4,W
03C4:  ADDWFC 02,F
03C6:  MOVLW  00
03C8:  ADDWFC 01,F
03CA:  MOVF   x96,W
03CC:  MULWF  x9A
03CE:  MOVF   FF3,W
03D0:  ADDWF  02,F
03D2:  MOVF   FF4,W
03D4:  ADDWFC 01,F
03D6:  INCF   00,F
03D8:  BTFSC  01.7
03DA:  BRA    03E6
03DC:  RLCF   x9E,F
03DE:  RLCF   03,F
03E0:  RLCF   02,F
03E2:  RLCF   01,F
03E4:  DECF   00,F
03E6:  MOVLW  00
03E8:  BTFSS  x9E.7
03EA:  BRA    0400
03EC:  INCF   03,F
03EE:  ADDWFC 02,F
03F0:  ADDWFC 01,F
03F2:  MOVF   01,W
03F4:  BNZ   0400
03F6:  MOVF   02,W
03F8:  BNZ   0400
03FA:  MOVF   03,W
03FC:  BNZ   0400
03FE:  INCF   00,F
0400:  BTFSC  x9D.7
0402:  BSF    01.7
0404:  BTFSS  x9D.7
0406:  BCF    01.7
0408:  BRA    0412
040A:  CLRF   00
040C:  CLRF   01
040E:  CLRF   02
0410:  CLRF   03
0412:  MOVLB  0
0414:  RETURN 0
0416:  MOVLW  80
0418:  BTFSS  FD8.1
041A:  BRA    0420
041C:  MOVLB  2
041E:  XORWF  x9C,F
0420:  MOVLB  2
0422:  CLRF   xA1
0424:  CLRF   xA2
0426:  MOVFF  298,2A0
042A:  MOVF   x9C,W
042C:  XORWF  xA0,F
042E:  MOVF   x97,W
0430:  BTFSC  FD8.2
0432:  BRA    05F2
0434:  MOVWF  x9F
0436:  MOVWF  00
0438:  MOVF   x9B,W
043A:  BTFSC  FD8.2
043C:  BRA    0604
043E:  SUBWF  x9F,F
0440:  BTFSC  FD8.2
0442:  BRA    054A
0444:  BNC   04C2
0446:  MOVFF  29C,2A5
044A:  BSF    xA5.7
044C:  MOVFF  29D,2A4
0450:  MOVFF  29E,2A3
0454:  CLRF   xA2
0456:  BCF    FD8.0
0458:  RRCF   xA5,F
045A:  RRCF   xA4,F
045C:  RRCF   xA3,F
045E:  RRCF   xA2,F
0460:  DECFSZ x9F,F
0462:  BRA    0454
0464:  BTFSS  xA0.7
0466:  BRA    046E
0468:  BSF    xA1.0
046A:  BRA    062C
046C:  BCF    xA1.0
046E:  BCF    x9F.0
0470:  BSF    xA1.4
0472:  MOVLW  02
0474:  MOVWF  FEA
0476:  MOVLW  9A
0478:  MOVWF  FE9
047A:  BRA    0652
047C:  BCF    xA1.4
047E:  BTFSC  xA0.7
0480:  BRA    0496
0482:  BTFSS  x9F.0
0484:  BRA    04AC
0486:  RRCF   xA5,F
0488:  RRCF   xA4,F
048A:  RRCF   xA3,F
048C:  RRCF   xA2,F
048E:  INCF   00,F
0490:  BTFSC  FD8.2
0492:  BRA    0622
0494:  BRA    04AC
0496:  BTFSC  xA5.7
0498:  BRA    04B2
049A:  BCF    FD8.0
049C:  RLCF   xA2,F
049E:  RLCF   xA3,F
04A0:  RLCF   xA4,F
04A2:  RLCF   xA5,F
04A4:  DECF   00,F
04A6:  BTFSC  FD8.2
04A8:  BRA    0622
04AA:  BRA    0496
04AC:  BSF    xA1.6
04AE:  BRA    058A
04B0:  BCF    xA1.6
04B2:  MOVFF  298,2A0
04B6:  BTFSS  x98.7
04B8:  BRA    04BE
04BA:  BSF    xA5.7
04BC:  BRA    0614
04BE:  BCF    xA5.7
04C0:  BRA    0614
04C2:  MOVFF  29B,29F
04C6:  MOVFF  29B,00
04CA:  MOVF   x97,W
04CC:  SUBWF  x9F,F
04CE:  MOVFF  298,2A5
04D2:  BSF    xA5.7
04D4:  MOVFF  299,2A4
04D8:  MOVFF  29A,2A3
04DC:  CLRF   xA2
04DE:  BCF    FD8.0
04E0:  RRCF   xA5,F
04E2:  RRCF   xA4,F
04E4:  RRCF   xA3,F
04E6:  RRCF   xA2,F
04E8:  DECFSZ x9F,F
04EA:  BRA    04DC
04EC:  BTFSS  xA0.7
04EE:  BRA    04F6
04F0:  BSF    xA1.1
04F2:  BRA    062C
04F4:  BCF    xA1.1
04F6:  BCF    x9F.0
04F8:  BSF    xA1.5
04FA:  MOVLW  02
04FC:  MOVWF  FEA
04FE:  MOVLW  9E
0500:  MOVWF  FE9
0502:  BRA    0652
0504:  BCF    xA1.5
0506:  BTFSC  xA0.7
0508:  BRA    051E
050A:  BTFSS  x9F.0
050C:  BRA    0534
050E:  RRCF   xA5,F
0510:  RRCF   xA4,F
0512:  RRCF   xA3,F
0514:  RRCF   xA2,F
0516:  INCF   00,F
0518:  BTFSC  FD8.2
051A:  BRA    0622
051C:  BRA    0534
051E:  BTFSC  xA5.7
0520:  BRA    053A
0522:  BCF    FD8.0
0524:  RLCF   xA2,F
0526:  RLCF   xA3,F
0528:  RLCF   xA4,F
052A:  RLCF   xA5,F
052C:  DECF   00,F
052E:  BTFSC  FD8.2
0530:  BRA    0622
0532:  BRA    051E
0534:  BSF    xA1.7
0536:  BRA    058A
0538:  BCF    xA1.7
053A:  MOVFF  29C,2A0
053E:  BTFSS  x9C.7
0540:  BRA    0546
0542:  BSF    xA5.7
0544:  BRA    0614
0546:  BCF    xA5.7
0548:  BRA    0614
054A:  MOVFF  29C,2A5
054E:  BSF    xA5.7
0550:  MOVFF  29D,2A4
0554:  MOVFF  29E,2A3
0558:  BTFSS  xA0.7
055A:  BRA    0564
055C:  BCF    xA5.7
055E:  BSF    xA1.2
0560:  BRA    062C
0562:  BCF    xA1.2
0564:  CLRF   xA2
0566:  BCF    x9F.0
0568:  MOVLW  02
056A:  MOVWF  FEA
056C:  MOVLW  9A
056E:  MOVWF  FE9
0570:  BRA    0652
0572:  BTFSC  xA0.7
0574:  BRA    05AE
0576:  MOVFF  298,2A0
057A:  BTFSS  x9F.0
057C:  BRA    058A
057E:  RRCF   xA5,F
0580:  RRCF   xA4,F
0582:  RRCF   xA3,F
0584:  RRCF   xA2,F
0586:  INCF   00,F
0588:  BZ    0622
058A:  BTFSS  xA2.7
058C:  BRA    05A4
058E:  INCF   xA3,F
0590:  BNZ   05A4
0592:  INCF   xA4,F
0594:  BNZ   05A4
0596:  INCF   xA5,F
0598:  BNZ   05A4
059A:  RRCF   xA5,F
059C:  RRCF   xA4,F
059E:  RRCF   xA3,F
05A0:  INCF   00,F
05A2:  BZ    0622
05A4:  BTFSC  xA1.6
05A6:  BRA    04B0
05A8:  BTFSC  xA1.7
05AA:  BRA    0538
05AC:  BRA    05E6
05AE:  MOVLW  80
05B0:  XORWF  xA5,F
05B2:  BTFSS  xA5.7
05B4:  BRA    05BE
05B6:  BRA    062C
05B8:  MOVFF  29C,2A0
05BC:  BRA    05D2
05BE:  MOVFF  298,2A0
05C2:  MOVF   xA5,F
05C4:  BNZ   05D2
05C6:  MOVF   xA4,F
05C8:  BNZ   05D2
05CA:  MOVF   xA3,F
05CC:  BNZ   05D2
05CE:  CLRF   00
05D0:  BRA    0614
05D2:  BTFSC  xA5.7
05D4:  BRA    05E6
05D6:  BCF    FD8.0
05D8:  RLCF   xA2,F
05DA:  RLCF   xA3,F
05DC:  RLCF   xA4,F
05DE:  RLCF   xA5,F
05E0:  DECFSZ 00,F
05E2:  BRA    05D2
05E4:  BRA    0622
05E6:  BTFSS  xA0.7
05E8:  BRA    05EE
05EA:  BSF    xA5.7
05EC:  BRA    0614
05EE:  BCF    xA5.7
05F0:  BRA    0614
05F2:  MOVFF  29B,00
05F6:  MOVFF  29C,2A5
05FA:  MOVFF  29D,2A4
05FE:  MOVFF  29E,2A3
0602:  BRA    0614
0604:  MOVFF  297,00
0608:  MOVFF  298,2A5
060C:  MOVFF  299,2A4
0610:  MOVFF  29A,2A3
0614:  MOVFF  2A5,01
0618:  MOVFF  2A4,02
061C:  MOVFF  2A3,03
0620:  BRA    068A
0622:  CLRF   00
0624:  CLRF   01
0626:  CLRF   02
0628:  CLRF   03
062A:  BRA    068A
062C:  CLRF   xA2
062E:  COMF   xA3,F
0630:  COMF   xA4,F
0632:  COMF   xA5,F
0634:  COMF   xA2,F
0636:  INCF   xA2,F
0638:  BNZ   0644
063A:  INCF   xA3,F
063C:  BNZ   0644
063E:  INCF   xA4,F
0640:  BNZ   0644
0642:  INCF   xA5,F
0644:  BTFSC  xA1.0
0646:  BRA    046C
0648:  BTFSC  xA1.1
064A:  BRA    04F4
064C:  BTFSC  xA1.2
064E:  BRA    0562
0650:  BRA    05B8
0652:  MOVF   FEF,W
0654:  ADDWF  xA3,F
0656:  BNC   0662
0658:  INCF   xA4,F
065A:  BNZ   0662
065C:  INCF   xA5,F
065E:  BTFSC  FD8.2
0660:  BSF    x9F.0
0662:  MOVF   FED,F
0664:  MOVF   FEF,W
0666:  ADDWF  xA4,F
0668:  BNC   0670
066A:  INCF   xA5,F
066C:  BTFSC  FD8.2
066E:  BSF    x9F.0
0670:  MOVF   FED,F
0672:  MOVF   FEF,W
0674:  BTFSC  FEF.7
0676:  BRA    067A
0678:  XORLW  80
067A:  ADDWF  xA5,F
067C:  BTFSC  FD8.0
067E:  BSF    x9F.0
0680:  BTFSC  xA1.4
0682:  BRA    047C
0684:  BTFSC  xA1.5
0686:  BRA    0504
0688:  BRA    0572
068A:  MOVLB  0
068C:  RETURN 0
068E:  MOVLW  8E
0690:  MOVWF  00
0692:  MOVLB  2
0694:  MOVF   x6C,W
0696:  SUBWF  00,F
0698:  MOVFF  26D,02
069C:  MOVFF  26E,01
06A0:  BSF    02.7
06A2:  MOVF   00,F
06A4:  BZ    06B8
06A6:  BCF    FD8.0
06A8:  MOVF   02,F
06AA:  BNZ   06B0
06AC:  MOVF   01,F
06AE:  BZ    06B8
06B0:  RRCF   02,F
06B2:  RRCF   01,F
06B4:  DECFSZ 00,F
06B6:  BRA    06A6
06B8:  BTFSS  x6D.7
06BA:  BRA    06C6
06BC:  COMF   01,F
06BE:  COMF   02,F
06C0:  INCF   01,F
06C2:  BTFSC  FD8.2
06C4:  INCF   02,F
06C6:  MOVLB  0
06C8:  RETURN 0
06CA:  MOVLB  2
06CC:  MOVF   x97,W
06CE:  BTFSC  FD8.2
06D0:  BRA    081C
06D2:  MOVWF  xA3
06D4:  MOVF   x9B,W
06D6:  BTFSC  FD8.2
06D8:  BRA    081C
06DA:  SUBWF  xA3,F
06DC:  BNC   06E8
06DE:  MOVLW  7F
06E0:  ADDWF  xA3,F
06E2:  BTFSC  FD8.0
06E4:  BRA    081C
06E6:  BRA    06F4
06E8:  MOVLW  81
06EA:  SUBWF  xA3,F
06EC:  BTFSS  FD8.0
06EE:  BRA    081C
06F0:  BTFSC  FD8.2
06F2:  BRA    081C
06F4:  MOVFF  2A3,00
06F8:  CLRF   01
06FA:  CLRF   02
06FC:  CLRF   03
06FE:  CLRF   xA2
0700:  MOVFF  298,2A1
0704:  BSF    xA1.7
0706:  MOVFF  299,2A0
070A:  MOVFF  29A,29F
070E:  MOVLW  19
0710:  MOVWF  xA3
0712:  MOVF   x9E,W
0714:  SUBWF  x9F,F
0716:  BC    0732
0718:  MOVLW  01
071A:  SUBWF  xA0,F
071C:  BC    0732
071E:  SUBWF  xA1,F
0720:  BC    0732
0722:  SUBWF  xA2,F
0724:  BC    0732
0726:  INCF   xA2,F
0728:  INCF   xA1,F
072A:  INCF   xA0,F
072C:  MOVF   x9E,W
072E:  ADDWF  x9F,F
0730:  BRA    0782
0732:  MOVF   x9D,W
0734:  SUBWF  xA0,F
0736:  BC    075C
0738:  MOVLW  01
073A:  SUBWF  xA1,F
073C:  BC    075C
073E:  SUBWF  xA2,F
0740:  BC    075C
0742:  INCF   xA2,F
0744:  INCF   xA1,F
0746:  MOVF   x9D,W
0748:  ADDWF  xA0,F
074A:  MOVF   x9E,W
074C:  ADDWF  x9F,F
074E:  BNC   0782
0750:  INCF   xA0,F
0752:  BNZ   0782
0754:  INCF   xA1,F
0756:  BNZ   0782
0758:  INCF   xA2,F
075A:  BRA    0782
075C:  MOVF   x9C,W
075E:  IORLW  80
0760:  SUBWF  xA1,F
0762:  BC    0780
0764:  MOVLW  01
0766:  SUBWF  xA2,F
0768:  BC    0780
076A:  INCF   xA2,F
076C:  MOVF   x9C,W
076E:  IORLW  80
0770:  ADDWF  xA1,F
0772:  MOVF   x9D,W
0774:  ADDWF  xA0,F
0776:  BNC   074A
0778:  INCF   xA1,F
077A:  BNZ   074A
077C:  INCF   xA2,F
077E:  BRA    074A
0780:  BSF    03.0
0782:  DECFSZ xA3,F
0784:  BRA    0788
0786:  BRA    079E
0788:  BCF    FD8.0
078A:  RLCF   x9F,F
078C:  RLCF   xA0,F
078E:  RLCF   xA1,F
0790:  RLCF   xA2,F
0792:  BCF    FD8.0
0794:  RLCF   03,F
0796:  RLCF   02,F
0798:  RLCF   01,F
079A:  RLCF   xA4,F
079C:  BRA    0712
079E:  BTFSS  xA4.0
07A0:  BRA    07AE
07A2:  BCF    FD8.0
07A4:  RRCF   01,F
07A6:  RRCF   02,F
07A8:  RRCF   03,F
07AA:  RRCF   xA4,F
07AC:  BRA    07B2
07AE:  DECF   00,F
07B0:  BZ    081C
07B2:  BTFSC  xA4.7
07B4:  BRA    07F2
07B6:  BCF    FD8.0
07B8:  RLCF   x9F,F
07BA:  RLCF   xA0,F
07BC:  RLCF   xA1,F
07BE:  RLCF   xA2,F
07C0:  MOVF   x9E,W
07C2:  SUBWF  x9F,F
07C4:  BC    07D4
07C6:  MOVLW  01
07C8:  SUBWF  xA0,F
07CA:  BC    07D4
07CC:  SUBWF  xA1,F
07CE:  BC    07D4
07D0:  SUBWF  xA2,F
07D2:  BNC   0808
07D4:  MOVF   x9D,W
07D6:  SUBWF  xA0,F
07D8:  BC    07E4
07DA:  MOVLW  01
07DC:  SUBWF  xA1,F
07DE:  BC    07E4
07E0:  SUBWF  xA2,F
07E2:  BNC   0808
07E4:  MOVF   x9C,W
07E6:  IORLW  80
07E8:  SUBWF  xA1,F
07EA:  BC    07F2
07EC:  MOVLW  01
07EE:  SUBWF  xA2,F
07F0:  BNC   0808
07F2:  INCF   03,F
07F4:  BNZ   0808
07F6:  INCF   02,F
07F8:  BNZ   0808
07FA:  INCF   01,F
07FC:  BNZ   0808
07FE:  INCF   00,F
0800:  BZ    081C
0802:  RRCF   01,F
0804:  RRCF   02,F
0806:  RRCF   03,F
0808:  MOVFF  298,2A3
080C:  MOVF   x9C,W
080E:  XORWF  xA3,F
0810:  BTFSS  xA3.7
0812:  BRA    0818
0814:  BSF    01.7
0816:  BRA    0824
0818:  BCF    01.7
081A:  BRA    0824
081C:  CLRF   00
081E:  CLRF   01
0820:  CLRF   02
0822:  CLRF   03
0824:  MOVLB  0
0826:  RETURN 0
*
0C9A:  MOVFF  268,26F
0C9E:  MOVLB  2
0CA0:  MOVF   x6C,W
0CA2:  XORWF  x6F,F
0CA4:  BTFSS  x6F.7
0CA6:  BRA    0CB2
0CA8:  BCF    FD8.2
0CAA:  BCF    FD8.0
0CAC:  BTFSC  x68.7
0CAE:  BSF    FD8.0
0CB0:  BRA    0D10
0CB2:  MOVFF  268,26F
0CB6:  MOVFF  26B,270
0CBA:  MOVF   x67,W
0CBC:  SUBWF  x70,F
0CBE:  BZ    0CCC
0CC0:  BTFSS  x6F.7
0CC2:  BRA    0D10
0CC4:  MOVF   FD8,W
0CC6:  XORLW  01
0CC8:  MOVWF  FD8
0CCA:  BRA    0D10
0CCC:  MOVFF  26C,270
0CD0:  MOVF   x68,W
0CD2:  SUBWF  x70,F
0CD4:  BZ    0CE2
0CD6:  BTFSS  x6F.7
0CD8:  BRA    0D10
0CDA:  MOVF   FD8,W
0CDC:  XORLW  01
0CDE:  MOVWF  FD8
0CE0:  BRA    0D10
0CE2:  MOVFF  26D,270
0CE6:  MOVF   x69,W
0CE8:  SUBWF  x70,F
0CEA:  BZ    0CF8
0CEC:  BTFSS  x6F.7
0CEE:  BRA    0D10
0CF0:  MOVF   FD8,W
0CF2:  XORLW  01
0CF4:  MOVWF  FD8
0CF6:  BRA    0D10
0CF8:  MOVFF  26E,270
0CFC:  MOVF   x6A,W
0CFE:  SUBWF  x70,F
0D00:  BZ    0D0E
0D02:  BTFSS  x6F.7
0D04:  BRA    0D10
0D06:  MOVF   FD8,W
0D08:  XORLW  01
0D0A:  MOVWF  FD8
0D0C:  BRA    0D10
0D0E:  BCF    FD8.0
0D10:  MOVLB  0
0D12:  RETURN 0
0D14:  MOVLB  2
0D16:  MOVF   x95,W
0D18:  SUBLW  B6
0D1A:  MOVWF  x95
0D1C:  CLRF   03
0D1E:  MOVFF  296,299
0D22:  BSF    x96.7
0D24:  BCF    FD8.0
0D26:  RRCF   x96,F
0D28:  RRCF   x97,F
0D2A:  RRCF   x98,F
0D2C:  RRCF   03,F
0D2E:  RRCF   02,F
0D30:  RRCF   01,F
0D32:  RRCF   00,F
0D34:  DECFSZ x95,F
0D36:  BRA    0D24
0D38:  BTFSS  x99.7
0D3A:  BRA    0D52
0D3C:  COMF   00,F
0D3E:  COMF   01,F
0D40:  COMF   02,F
0D42:  COMF   03,F
0D44:  INCF   00,F
0D46:  BTFSC  FD8.2
0D48:  INCF   01,F
0D4A:  BTFSC  FD8.2
0D4C:  INCF   02,F
0D4E:  BTFSC  FD8.2
0D50:  INCF   03,F
0D52:  MOVLB  0
0D54:  RETURN 0
0D56:  BTFSC  FD8.1
0D58:  BRA    0D62
0D5A:  MOVLW  02
0D5C:  MOVWF  FEA
0D5E:  MOVLW  9D
0D60:  MOVWF  FE9
0D62:  CLRF   00
0D64:  CLRF   01
0D66:  CLRF   02
0D68:  CLRF   03
0D6A:  MOVLB  2
0D6C:  CLRF   x9D
0D6E:  CLRF   x9E
0D70:  CLRF   x9F
0D72:  CLRF   xA0
0D74:  MOVF   x9C,W
0D76:  IORWF  x9B,W
0D78:  IORWF  x9A,W
0D7A:  IORWF  x99,W
0D7C:  BZ    0DD6
0D7E:  MOVLW  20
0D80:  MOVWF  xA1
0D82:  BCF    FD8.0
0D84:  RLCF   x95,F
0D86:  RLCF   x96,F
0D88:  RLCF   x97,F
0D8A:  RLCF   x98,F
0D8C:  RLCF   x9D,F
0D8E:  RLCF   x9E,F
0D90:  RLCF   x9F,F
0D92:  RLCF   xA0,F
0D94:  MOVF   x9C,W
0D96:  SUBWF  xA0,W
0D98:  BNZ   0DAA
0D9A:  MOVF   x9B,W
0D9C:  SUBWF  x9F,W
0D9E:  BNZ   0DAA
0DA0:  MOVF   x9A,W
0DA2:  SUBWF  x9E,W
0DA4:  BNZ   0DAA
0DA6:  MOVF   x99,W
0DA8:  SUBWF  x9D,W
0DAA:  BNC   0DCA
0DAC:  MOVF   x99,W
0DAE:  SUBWF  x9D,F
0DB0:  MOVF   x9A,W
0DB2:  BTFSS  FD8.0
0DB4:  INCFSZ x9A,W
0DB6:  SUBWF  x9E,F
0DB8:  MOVF   x9B,W
0DBA:  BTFSS  FD8.0
0DBC:  INCFSZ x9B,W
0DBE:  SUBWF  x9F,F
0DC0:  MOVF   x9C,W
0DC2:  BTFSS  FD8.0
0DC4:  INCFSZ x9C,W
0DC6:  SUBWF  xA0,F
0DC8:  BSF    FD8.0
0DCA:  RLCF   00,F
0DCC:  RLCF   01,F
0DCE:  RLCF   02,F
0DD0:  RLCF   03,F
0DD2:  DECFSZ xA1,F
0DD4:  BRA    0D82
0DD6:  MOVFF  29D,FEF
0DDA:  MOVFF  29E,FEC
0DDE:  MOVFF  29F,FEC
0DE2:  MOVFF  2A0,FEC
0DE6:  MOVLB  0
0DE8:  RETURN 0
0DEA:  MOVFF  263,FEA
0DEE:  MOVFF  262,FE9
0DF2:  MOVLB  2
0DF4:  MOVFF  274,FEF
0DF8:  INCF   FE9,F
0DFA:  BTFSC  FD8.2
0DFC:  INCF   FEA,F
0DFE:  CLRF   FEF
0E00:  INCF   x62,F
0E02:  BTFSC  FD8.2
0E04:  INCF   x63,F
0E06:  MOVLB  0
0E08:  RETURN 0
0E0A:  MOVF   FE9,W
0E0C:  MOVLB  2
0E0E:  MOVWF  x6C
0E10:  MOVF   x6B,W
0E12:  MOVWF  x6E
0E14:  BZ    0E4E
0E16:  MOVFF  26A,298
0E1A:  MOVFF  269,297
0E1E:  MOVFF  268,296
0E22:  MOVFF  267,295
0E26:  CLRF   x9C
0E28:  CLRF   x9B
0E2A:  MOVLW  20
0E2C:  MOVWF  x9A
0E2E:  MOVLW  82
0E30:  MOVWF  x99
0E32:  MOVLB  0
0E34:  CALL   0320
0E38:  MOVFF  03,26A
0E3C:  MOVFF  02,269
0E40:  MOVFF  01,268
0E44:  MOVFF  00,267
0E48:  MOVLB  2
0E4A:  DECFSZ x6E,F
0E4C:  BRA    0E16
0E4E:  MOVFF  26A,298
0E52:  MOVFF  269,297
0E56:  MOVFF  268,296
0E5A:  MOVFF  267,295
0E5E:  MOVLB  0
0E60:  RCALL  0D14
0E62:  MOVFF  03,26A
0E66:  MOVFF  02,269
0E6A:  MOVFF  01,268
0E6E:  MOVFF  00,267
0E72:  MOVLB  2
0E74:  BTFSS  x6A.7
0E76:  BRA    0E92
0E78:  DECF   x6C,F
0E7A:  BSF    x6C.5
0E7C:  COMF   x67,F
0E7E:  COMF   x68,F
0E80:  COMF   x69,F
0E82:  COMF   x6A,F
0E84:  INCF   x67,F
0E86:  BTFSC  FD8.2
0E88:  INCF   x68,F
0E8A:  BTFSC  FD8.2
0E8C:  INCF   x69,F
0E8E:  BTFSC  FD8.2
0E90:  INCF   x6A,F
0E92:  MOVLW  3B
0E94:  MOVWF  x73
0E96:  MOVLW  9A
0E98:  MOVWF  x72
0E9A:  MOVLW  CA
0E9C:  MOVWF  x71
0E9E:  CLRF   x70
0EA0:  MOVLW  0A
0EA2:  MOVWF  x6E
0EA4:  MOVF   x6B,W
0EA6:  BTFSC  FD8.2
0EA8:  INCF   x6C,F
0EAA:  BSF    FD8.1
0EAC:  MOVLW  02
0EAE:  MOVWF  FEA
0EB0:  MOVLW  67
0EB2:  MOVWF  FE9
0EB4:  MOVFF  26A,298
0EB8:  MOVFF  269,297
0EBC:  MOVFF  268,296
0EC0:  MOVFF  267,295
0EC4:  MOVFF  273,29C
0EC8:  MOVFF  272,29B
0ECC:  MOVFF  271,29A
0ED0:  MOVFF  270,299
0ED4:  MOVLB  0
0ED6:  RCALL  0D56
0ED8:  MOVF   01,W
0EDA:  MOVF   00,F
0EDC:  BNZ   0F04
0EDE:  MOVLB  2
0EE0:  INCF   x6B,W
0EE2:  SUBWF  x6E,W
0EE4:  BTFSS  FD8.2
0EE6:  BRA    0EEC
0EE8:  MOVLB  0
0EEA:  BRA    0F04
0EEC:  MOVF   x6C,W
0EEE:  BZ    0F0A
0EF0:  ANDLW  0F
0EF2:  SUBWF  x6E,W
0EF4:  BZ    0EF8
0EF6:  BC    0F78
0EF8:  BTFSC  x6C.7
0EFA:  BRA    0F78
0EFC:  BTFSC  x6C.6
0EFE:  BRA    0F0A
0F00:  MOVLW  20
0F02:  BRA    0F6C
0F04:  MOVLW  20
0F06:  MOVLB  2
0F08:  ANDWF  x6C,F
0F0A:  BTFSS  x6C.5
0F0C:  BRA    0F2A
0F0E:  BCF    x6C.5
0F10:  MOVF   x6B,W
0F12:  BTFSS  FD8.2
0F14:  DECF   x6C,F
0F16:  MOVF   00,W
0F18:  MOVWF  x6C
0F1A:  MOVLW  2D
0F1C:  MOVWF  x74
0F1E:  MOVLB  0
0F20:  RCALL  0DEA
0F22:  MOVLB  2
0F24:  MOVF   x6C,W
0F26:  MOVWF  00
0F28:  CLRF   x6C
0F2A:  MOVF   x6B,W
0F2C:  SUBWF  x6E,W
0F2E:  BNZ   0F48
0F30:  MOVF   00,W
0F32:  MOVWF  x6C
0F34:  MOVLW  2E
0F36:  MOVWF  x74
0F38:  MOVLB  0
0F3A:  RCALL  0DEA
0F3C:  MOVLB  2
0F3E:  MOVF   x6C,W
0F40:  MOVWF  00
0F42:  MOVLW  20
0F44:  ANDWF  x6C,F
0F46:  MOVLW  00
0F48:  MOVLW  30
0F4A:  BTFSS  x6C.5
0F4C:  BRA    0F6C
0F4E:  BCF    x6C.5
0F50:  MOVF   x6B,W
0F52:  BTFSS  FD8.2
0F54:  DECF   x6C,F
0F56:  MOVF   00,W
0F58:  MOVWF  x6C
0F5A:  MOVLW  2D
0F5C:  MOVWF  x74
0F5E:  MOVLB  0
0F60:  RCALL  0DEA
0F62:  MOVLB  2
0F64:  MOVF   x6C,W
0F66:  MOVWF  00
0F68:  CLRF   x6C
0F6A:  MOVLW  30
0F6C:  ADDWF  00,F
0F6E:  MOVFF  00,274
0F72:  MOVLB  0
0F74:  RCALL  0DEA
0F76:  MOVLB  2
0F78:  BCF    FD8.1
0F7A:  MOVFF  273,298
0F7E:  MOVFF  272,297
0F82:  MOVFF  271,296
0F86:  MOVFF  270,295
0F8A:  CLRF   x9C
0F8C:  CLRF   x9B
0F8E:  CLRF   x9A
0F90:  MOVLW  0A
0F92:  MOVWF  x99
0F94:  MOVLB  0
0F96:  RCALL  0D56
0F98:  MOVFF  03,273
0F9C:  MOVFF  02,272
0FA0:  MOVFF  01,271
0FA4:  MOVFF  00,270
0FA8:  MOVLB  2
0FAA:  DECFSZ x6E,F
0FAC:  BRA    0EAA
0FAE:  MOVLB  0
0FB0:  RETURN 0
*
14A8:  TBLRD*+
14AA:  MOVF   FF5,F
14AC:  BZ    14C8
14AE:  MOVFF  FF6,280
14B2:  MOVFF  FF7,281
14B6:  MOVF   FF5,W
14B8:  BTFSS  F9E.4
14BA:  BRA    14B8
14BC:  MOVWF  FAD
14BE:  MOVFF  280,FF6
14C2:  MOVFF  281,FF7
14C6:  BRA    14A8
14C8:  GOTO   17C8 (RETURN)
14CC:  TBLRD*+
14CE:  MOVFF  FF6,289
14D2:  MOVFF  FF7,28A
14D6:  MOVF   FF5,W
14D8:  BTFSS  F9E.4
14DA:  BRA    14D8
14DC:  MOVWF  FAD
14DE:  MOVFF  289,FF6
14E2:  MOVFF  28A,FF7
14E6:  MOVLB  2
14E8:  DECFSZ x88,F
14EA:  BRA    14EE
14EC:  BRA    14F2
14EE:  MOVLB  0
14F0:  BRA    14CC
14F2:  MOVLB  0
14F4:  RETURN 0
14F6:  MOVF   FE9,W
14F8:  MOVLB  2
14FA:  MOVWF  x8D
14FC:  MOVF   x8C,W
14FE:  MOVWF  x8F
1500:  BZ    153A
1502:  MOVFF  28B,298
1506:  MOVFF  28A,297
150A:  MOVFF  289,296
150E:  MOVFF  288,295
1512:  CLRF   x9C
1514:  CLRF   x9B
1516:  MOVLW  20
1518:  MOVWF  x9A
151A:  MOVLW  82
151C:  MOVWF  x99
151E:  MOVLB  0
1520:  CALL   0320
1524:  MOVFF  03,28B
1528:  MOVFF  02,28A
152C:  MOVFF  01,289
1530:  MOVFF  00,288
1534:  MOVLB  2
1536:  DECFSZ x8F,F
1538:  BRA    1502
153A:  MOVFF  28B,298
153E:  MOVFF  28A,297
1542:  MOVFF  289,296
1546:  MOVFF  288,295
154A:  MOVLB  0
154C:  CALL   0D14
1550:  MOVFF  03,28B
1554:  MOVFF  02,28A
1558:  MOVFF  01,289
155C:  MOVFF  00,288
1560:  MOVLB  2
1562:  BTFSS  x8B.7
1564:  BRA    1580
1566:  DECF   x8D,F
1568:  BSF    x8D.5
156A:  COMF   x88,F
156C:  COMF   x89,F
156E:  COMF   x8A,F
1570:  COMF   x8B,F
1572:  INCF   x88,F
1574:  BTFSC  FD8.2
1576:  INCF   x89,F
1578:  BTFSC  FD8.2
157A:  INCF   x8A,F
157C:  BTFSC  FD8.2
157E:  INCF   x8B,F
1580:  MOVLW  3B
1582:  MOVWF  x94
1584:  MOVLW  9A
1586:  MOVWF  x93
1588:  MOVLW  CA
158A:  MOVWF  x92
158C:  CLRF   x91
158E:  MOVLW  0A
1590:  MOVWF  x8F
1592:  MOVF   x8C,W
1594:  BTFSC  FD8.2
1596:  INCF   x8D,F
1598:  BSF    FD8.1
159A:  MOVLW  02
159C:  MOVWF  FEA
159E:  MOVLW  88
15A0:  MOVWF  FE9
15A2:  MOVFF  28B,298
15A6:  MOVFF  28A,297
15AA:  MOVFF  289,296
15AE:  MOVFF  288,295
15B2:  MOVFF  294,29C
15B6:  MOVFF  293,29B
15BA:  MOVFF  292,29A
15BE:  MOVFF  291,299
15C2:  MOVLB  0
15C4:  CALL   0D56
15C8:  MOVF   01,W
15CA:  MOVF   00,F
15CC:  BNZ   15F4
15CE:  MOVLB  2
15D0:  INCF   x8C,W
15D2:  SUBWF  x8F,W
15D4:  BTFSS  FD8.2
15D6:  BRA    15DC
15D8:  MOVLB  0
15DA:  BRA    15F4
15DC:  MOVF   x8D,W
15DE:  BZ    15FA
15E0:  ANDLW  0F
15E2:  SUBWF  x8F,W
15E4:  BZ    15E8
15E6:  BC    1660
15E8:  BTFSC  x8D.7
15EA:  BRA    1660
15EC:  BTFSC  x8D.6
15EE:  BRA    15FA
15F0:  MOVLW  20
15F2:  BRA    1656
15F4:  MOVLW  20
15F6:  MOVLB  2
15F8:  ANDWF  x8D,F
15FA:  BTFSS  x8D.5
15FC:  BRA    1618
15FE:  BCF    x8D.5
1600:  MOVF   x8C,W
1602:  BTFSS  FD8.2
1604:  DECF   x8D,F
1606:  MOVF   00,W
1608:  MOVWF  x8D
160A:  MOVLW  2D
160C:  BTFSS  F9E.4
160E:  BRA    160C
1610:  MOVWF  FAD
1612:  MOVF   x8D,W
1614:  MOVWF  00
1616:  CLRF   x8D
1618:  MOVF   x8C,W
161A:  SUBWF  x8F,W
161C:  BNZ   1634
161E:  MOVF   00,W
1620:  MOVWF  x8D
1622:  MOVLW  2E
1624:  BTFSS  F9E.4
1626:  BRA    1624
1628:  MOVWF  FAD
162A:  MOVF   x8D,W
162C:  MOVWF  00
162E:  MOVLW  20
1630:  ANDWF  x8D,F
1632:  MOVLW  00
1634:  MOVLW  30
1636:  BTFSS  x8D.5
1638:  BRA    1656
163A:  BCF    x8D.5
163C:  MOVF   x8C,W
163E:  BTFSS  FD8.2
1640:  DECF   x8D,F
1642:  MOVF   00,W
1644:  MOVWF  x8D
1646:  MOVLW  2D
1648:  BTFSS  F9E.4
164A:  BRA    1648
164C:  MOVWF  FAD
164E:  MOVF   x8D,W
1650:  MOVWF  00
1652:  CLRF   x8D
1654:  MOVLW  30
1656:  ADDWF  00,F
1658:  MOVF   00,W
165A:  BTFSS  F9E.4
165C:  BRA    165A
165E:  MOVWF  FAD
1660:  BCF    FD8.1
1662:  MOVFF  294,298
1666:  MOVFF  293,297
166A:  MOVFF  292,296
166E:  MOVFF  291,295
1672:  CLRF   x9C
1674:  CLRF   x9B
1676:  CLRF   x9A
1678:  MOVLW  0A
167A:  MOVWF  x99
167C:  MOVLB  0
167E:  CALL   0D56
1682:  MOVFF  03,294
1686:  MOVFF  02,293
168A:  MOVFF  01,292
168E:  MOVFF  00,291
1692:  MOVLB  2
1694:  DECFSZ x8F,F
1696:  BRA    1598
1698:  MOVLB  0
169A:  RETURN 0
....................  
.................... #list 
....................  
.................... #fuses NOPROTECT, NOWDT 
.................... #device adc = 10 
.................... #use delay(clock=8000000) 
*
021A:  MOVLW  02
021C:  MOVWF  FEA
021E:  MOVLW  81
0220:  MOVWF  FE9
0222:  MOVF   FEF,W
0224:  BZ    0240
0226:  MOVLW  02
0228:  MOVWF  01
022A:  CLRF   00
022C:  DECFSZ 00,F
022E:  BRA    022C
0230:  DECFSZ 01,F
0232:  BRA    022A
0234:  MOVLW  97
0236:  MOVWF  00
0238:  DECFSZ 00,F
023A:  BRA    0238
023C:  DECFSZ FEF,F
023E:  BRA    0226
0240:  RETURN 0
.................... #use RS232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_C6, RCV=PIN_C7) 
....................  
.................... #include "Definitions.h" 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
*
096E:  MOVLB  2
0970:  CLRF   x8B
0972:  CLRF   x8A
0974:  CLRF   x89
0976:  MOVLW  7F
0978:  MOVWF  x88
097A:  CLRF   x8F
097C:  CLRF   x8E
097E:  CLRF   x8D
0980:  CLRF   x8C
0982:  BSF    x90.0
0984:  BCF    x90.1
0986:  BCF    x90.2
0988:  CLRF   x92
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
098A:  MOVF   x84,W
098C:  IORWF  x85,W
098E:  BNZ   099A
....................       return 0; 
0990:  CLRF   00
0992:  CLRF   01
0994:  CLRF   02
0996:  CLRF   03
0998:  BRA    0BB6
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
099A:  MOVF   x92,W
099C:  INCF   x92,F
099E:  ADDWF  x84,W
09A0:  MOVWF  FE9
09A2:  MOVLW  00
09A4:  ADDWFC x85,W
09A6:  MOVWF  FEA
09A8:  MOVFF  FEF,291
09AC:  MOVF   x91,F
09AE:  BTFSC  FD8.2
09B0:  BRA    0B3A
....................    { 
....................       if (skip && !isspace(c)) 
09B2:  BTFSS  x90.0
09B4:  BRA    09D4
09B6:  MOVF   x91,W
09B8:  SUBLW  20
09BA:  BZ    09D4
....................       { 
....................          skip = 0; 
09BC:  BCF    x90.0
....................          if (c == '+') 
09BE:  MOVF   x91,W
09C0:  SUBLW  2B
09C2:  BNZ   09CA
....................          { 
....................             sign = 0; 
09C4:  BCF    x90.1
....................             continue; 
09C6:  BRA    0B22
....................          }             
09C8:  BRA    09D4
....................          else if (c == '-') 
09CA:  MOVF   x91,W
09CC:  SUBLW  2D
09CE:  BNZ   09D4
....................          { 
....................             sign = 1; 
09D0:  BSF    x90.1
....................             continue; 
09D2:  BRA    0B22
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
09D4:  BTFSC  x90.0
09D6:  BRA    09E6
09D8:  MOVF   x91,W
09DA:  SUBLW  2E
09DC:  BNZ   09E6
09DE:  BTFSC  x90.2
09E0:  BRA    09E6
....................          point = 1; 
09E2:  BSF    x90.2
09E4:  BRA    0B22
....................       else if (!skip && isdigit(c)) 
09E6:  BTFSC  x90.0
09E8:  BRA    0B1C
09EA:  MOVF   x91,W
09EC:  SUBLW  2F
09EE:  BTFSC  FD8.0
09F0:  BRA    0B1C
09F2:  MOVF   x91,W
09F4:  SUBLW  39
09F6:  BTFSS  FD8.0
09F8:  BRA    0B1C
....................       { 
....................          c -= '0'; 
09FA:  MOVLW  30
09FC:  SUBWF  x91,F
....................          if (point) 
09FE:  BTFSS  x90.2
0A00:  BRA    0AA8
....................          { 
....................             pow10 = pow10 * 10.0; 
0A02:  MOVFF  28B,298
0A06:  MOVFF  28A,297
0A0A:  MOVFF  289,296
0A0E:  MOVFF  288,295
0A12:  CLRF   x9C
0A14:  CLRF   x9B
0A16:  MOVLW  20
0A18:  MOVWF  x9A
0A1A:  MOVLW  82
0A1C:  MOVWF  x99
0A1E:  MOVLB  0
0A20:  RCALL  0320
0A22:  MOVFF  03,28B
0A26:  MOVFF  02,28A
0A2A:  MOVFF  01,289
0A2E:  MOVFF  00,288
....................             result += (float)c / pow10;    
0A32:  MOVLB  2
0A34:  CLRF   x98
0A36:  MOVFF  291,297
0A3A:  MOVLB  0
0A3C:  RCALL  02EA
0A3E:  MOVFF  03,296
0A42:  MOVFF  02,295
0A46:  MOVFF  01,294
0A4A:  MOVFF  00,293
0A4E:  MOVFF  03,29A
0A52:  MOVFF  02,299
0A56:  MOVFF  01,298
0A5A:  MOVFF  00,297
0A5E:  MOVFF  28B,29E
0A62:  MOVFF  28A,29D
0A66:  MOVFF  289,29C
0A6A:  MOVFF  288,29B
0A6E:  RCALL  06CA
0A70:  BCF    FD8.1
0A72:  MOVFF  28F,29A
0A76:  MOVFF  28E,299
0A7A:  MOVFF  28D,298
0A7E:  MOVFF  28C,297
0A82:  MOVFF  03,29E
0A86:  MOVFF  02,29D
0A8A:  MOVFF  01,29C
0A8E:  MOVFF  00,29B
0A92:  RCALL  0416
0A94:  MOVFF  03,28F
0A98:  MOVFF  02,28E
0A9C:  MOVFF  01,28D
0AA0:  MOVFF  00,28C
....................          } 
0AA4:  BRA    0B18
0AA6:  MOVLB  2
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
0AA8:  CLRF   x98
0AAA:  CLRF   x97
0AAC:  MOVLW  20
0AAE:  MOVWF  x96
0AB0:  MOVLW  82
0AB2:  MOVWF  x95
0AB4:  MOVFF  28F,29C
0AB8:  MOVFF  28E,29B
0ABC:  MOVFF  28D,29A
0AC0:  MOVFF  28C,299
0AC4:  MOVLB  0
0AC6:  RCALL  0320
0AC8:  MOVFF  03,296
0ACC:  MOVFF  02,295
0AD0:  MOVFF  01,294
0AD4:  MOVFF  00,293
0AD8:  MOVLB  2
0ADA:  CLRF   x98
0ADC:  MOVFF  291,297
0AE0:  MOVLB  0
0AE2:  RCALL  02EA
0AE4:  BCF    FD8.1
0AE6:  MOVFF  296,29A
0AEA:  MOVFF  295,299
0AEE:  MOVFF  294,298
0AF2:  MOVFF  293,297
0AF6:  MOVFF  03,29E
0AFA:  MOVFF  02,29D
0AFE:  MOVFF  01,29C
0B02:  MOVFF  00,29B
0B06:  RCALL  0416
0B08:  MOVFF  03,28F
0B0C:  MOVFF  02,28E
0B10:  MOVFF  01,28D
0B14:  MOVFF  00,28C
....................          } 
....................       } 
0B18:  BRA    0B24
0B1A:  MOVLB  2
....................       else if (!skip) 
0B1C:  BTFSC  x90.0
0B1E:  BRA    0B22
....................          break; 
0B20:  BRA    0B3A
0B22:  MOVLB  0
0B24:  MOVLB  2
0B26:  MOVF   x92,W
0B28:  INCF   x92,F
0B2A:  ADDWF  x84,W
0B2C:  MOVWF  FE9
0B2E:  MOVLW  00
0B30:  ADDWFC x85,W
0B32:  MOVWF  FEA
0B34:  MOVFF  FEF,291
0B38:  BRA    09AC
....................    } 
....................  
....................    if (sign) 
0B3A:  BTFSS  x90.1
0B3C:  BRA    0B72
....................       result = -1*result; 
0B3E:  CLRF   x98
0B40:  CLRF   x97
0B42:  MOVLW  80
0B44:  MOVWF  x96
0B46:  MOVLW  7F
0B48:  MOVWF  x95
0B4A:  MOVFF  28F,29C
0B4E:  MOVFF  28E,29B
0B52:  MOVFF  28D,29A
0B56:  MOVFF  28C,299
0B5A:  MOVLB  0
0B5C:  CALL   0320
0B60:  MOVFF  03,28F
0B64:  MOVFF  02,28E
0B68:  MOVFF  01,28D
0B6C:  MOVFF  00,28C
0B70:  MOVLB  2
....................        
....................    if(endptr) 
0B72:  MOVF   x86,W
0B74:  IORWF  x87,W
0B76:  BZ    0BA6
....................    { 
....................       if (ptr) { 
0B78:  MOVF   x92,F
0B7A:  BZ    0B94
....................          ptr--; 
0B7C:  DECF   x92,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
0B7E:  MOVFF  286,FE9
0B82:  MOVFF  287,FEA
0B86:  MOVF   x92,W
0B88:  ADDWF  x84,W
0B8A:  MOVWF  FEF
0B8C:  MOVLW  00
0B8E:  ADDWFC x85,W
0B90:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
0B92:  BRA    0BA6
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
0B94:  MOVFF  286,FE9
0B98:  MOVFF  287,FEA
0B9C:  MOVFF  285,FEC
0BA0:  MOVF   FED,F
0BA2:  MOVFF  284,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
0BA6:  MOVFF  28C,00
0BAA:  MOVFF  28D,01
0BAE:  MOVFF  28E,02
0BB2:  MOVFF  28F,03
0BB6:  MOVLB  0
0BB8:  RETURN 0
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #define ONE_SEC 33  // 1000/((4/8000)*(65535)(1)) = 32.767 
.................... #define TEN_SEC ONE_SEC*10  
.................... #define buf_length 255 
.................... #define TELEPHONE_LENGHT 10 
.................... #define TELEPHONE_ADDRESS 25 
.................... #define DISTANCE_LIMIT 512 
.................... // Send message stuff 
.................... #define Send_Message input(PIN_b0) 
....................  
.................... volatile unsigned int8 timerCounter = 0; 
.................... volatile unsigned int16 timerGPS    = 0; 
....................  
.................... // GPS Variables 
.................... char LatRead[10], LonRead[10]; 
.................... int savePosition =  0; 
.................... int GPS_Connected = 0; 
.................... float latitud = 0, longitud = 0; 
.................... char LatWrite[10]; 
.................... char LonWrite[10]; 
.................... float latitudConverted  = 0; 
.................... float longitudConverted = 0; 
....................  
.................... // Power Moduled variables 
.................... //int duty = 0; 
....................  
.................... // Phone message variables 
.................... //char _Cel1[8], _Cel2[8]; 
.................... //float Num1, Num2; 
....................  
.................... // Buffer variables  
.................... volatile char str[buf_length], buf[buf_length]; 
.................... int str_flag = 0, flag_buf = 0, str_flag2=0; 
.................... int i = 0; 
....................  
.................... // ADC Variables 
.................... //int16 data_adc0 = 0, mmDistance = 0, distancePower = 0;  
.................... float voltage = 0; 
....................  
....................  
.................... void setup(); 
.................... void start_alert(); 
.................... void Motor1_Start(); 
.................... void If_Message(void); 
.................... void process_tel_number(); 
.................... void Get_GPS(); 
.................... void gps_info_processor(void); 
.................... void dummyFunction(char characterRecived); 
.................... int16 AdcReadAndProcessing(); 
....................  
.................... #INT_TIMER0 
.................... void t0() 
.................... { 
....................    timerCounter++; 
*
00BA:  INCF   1F,F
....................    if(timerCounter == ONE_SEC) 
00BC:  MOVF   1F,W
00BE:  SUBLW  21
00C0:  BNZ   00C8
....................    { 
....................       output_toggle(pin_a5); 
00C2:  BCF    F92.5
00C4:  BTG    F89.5
....................       timerCounter = 0; 
00C6:  CLRF   1F
....................    } 
....................    timerGPS++; 
00C8:  INCF   20,F
00CA:  BTFSC  FD8.2
00CC:  INCF   21,F
....................    if(timerGPS == TEN_SEC) 
00CE:  MOVF   20,W
00D0:  SUBLW  4A
00D2:  BNZ   00E0
00D4:  DECFSZ 21,W
00D6:  BRA    00E0
....................    { 
....................       savePosition = 1; 
00D8:  MOVLW  01
00DA:  MOVWF  36
....................       timerGPS = 0; 
00DC:  CLRF   21
00DE:  CLRF   20
....................    } 
.................... } 
....................  
00E0:  BCF    FF2.2
00E2:  GOTO   006C
.................... #INT_rda 
.................... void rda_isr() 
*
0184:  BTFSS  F9E.5
0186:  BRA    0184
0188:  MOVFF  FAE,2A7
018C:  MOVLB  2
.................... { 
....................    volatile char characterRecived = getchar (); 
....................    dummyFunction(characterRecived); 
018E:  MOVFF  2A7,2A8
0192:  MOVLB  0
0194:  BRA    00E6
0196:  BCF    F9E.5
0198:  GOTO   006C
.................... } 
....................  
.................... void main() 
*
19C2:  CLRF   FF8
19C4:  BCF    FD0.7
19C6:  BSF    07.7
19C8:  BCF    FB8.3
19CA:  MOVLW  0C
19CC:  MOVWF  FAF
19CE:  MOVLW  A2
19D0:  MOVWF  FAC
19D2:  MOVLW  90
19D4:  MOVWF  FAB
19D6:  CLRF   1F
19D8:  CLRF   21
19DA:  CLRF   20
19DC:  CLRF   36
19DE:  CLRF   37
19E0:  CLRF   3B
19E2:  CLRF   3A
19E4:  CLRF   39
19E6:  CLRF   38
19E8:  CLRF   3F
19EA:  CLRF   3E
19EC:  CLRF   3D
19EE:  CLRF   3C
19F0:  CLRF   57
19F2:  CLRF   56
19F4:  CLRF   55
19F6:  CLRF   54
19F8:  CLRF   5B
19FA:  CLRF   5A
19FC:  CLRF   59
19FE:  CLRF   58
1A00:  MOVLB  2
1A02:  CLRF   x5A
1A04:  CLRF   x5B
1A06:  CLRF   x5C
1A08:  CLRF   x5D
1A0A:  CLRF   x61
1A0C:  CLRF   x60
1A0E:  CLRF   x5F
1A10:  CLRF   x5E
1A12:  CLRF   x63
1A14:  CLRF   x62
1A16:  MOVF   FC1,W
1A18:  ANDLW  C0
1A1A:  IORLW  0F
1A1C:  MOVWF  FC1
1A1E:  MOVLW  07
1A20:  MOVWF  FB4
1A22:  CLRF   19
1A24:  CLRF   1A
.................... { 
....................    int16 distancePower; 
....................    setup(); 
1A26:  MOVLB  0
1A28:  GOTO   01E8
....................    start_alert(); 
1A2C:  GOTO   0242
....................    Motor1_Start(); // Starts motor and confgures timer2 
1A30:  GOTO   0290
....................     
....................    while(TRUE) 
....................    {     
....................       distancePower = AdcReadAndProcessing(); 
1A34:  GOTO   0828
1A38:  MOVFF  02,265
1A3C:  MOVFF  01,264
....................       set_pwm1_duty(distancePower); 
1A40:  MOVFF  265,02
1A44:  MOVFF  264,01
1A48:  RRCF   02,F
1A4A:  RRCF   01,F
1A4C:  RRCF   02,F
1A4E:  RRCF   01,F
1A50:  RRCF   02,F
1A52:  MOVFF  01,FBE
1A56:  RRCF   02,F
1A58:  RRCF   02,W
1A5A:  ANDLW  30
1A5C:  MOVWF  00
1A5E:  MOVF   FBD,W
1A60:  ANDLW  CF
1A62:  IORWF  00,W
1A64:  MOVWF  FBD
....................       Get_GPS(); 
1A66:  GOTO   0BBA
....................       gps_info_processor(); 
1A6A:  GOTO   0FB2
....................       If_Message(); 
1A6E:  BRA    169C
....................       process_tel_number();  
1A70:  BRA    190E
1A72:  BRA    1A34
....................    } 
.................... } 
....................  
1A74:  SLEEP 
.................... void setup() 
.................... { 
....................    setup_oscillator( OSC_8MHZ | OSC_INTRC );  
*
01E8:  MOVLW  72
01EA:  MOVWF  FD3
01EC:  MOVF   FD3,W
....................    setup_adc (ADC_CLOCK_INTERNAL); 
01EE:  BSF    FC0.0
01F0:  BSF    FC0.1
01F2:  BSF    FC0.2
01F4:  BSF    FC0.7
01F6:  BSF    FC2.0
....................    setup_adc_ports (AN0 | VSS_VDD); //Read ADC0 
01F8:  MOVF   FC1,W
01FA:  ANDLW  C0
01FC:  IORLW  0E
01FE:  MOVWF  FC1
....................    enable_interrupts(INT_TIMER0); 
0200:  BSF    FF2.5
....................    enable_interrupts(INT_RDA);        
0202:  BSF    F9D.5
....................    enable_interrupts(GLOBAL); 
0204:  MOVLW  C0
0206:  IORWF  FF2,F
....................    set_timer0(65535); 
0208:  SETF   FD7
020A:  SETF   FD6
....................    setup_counters(T0_DIV_1, 1); 
020C:  BCF    FD1.0
020E:  MOVLW  89
0210:  MOVWF  FD5
....................    setup_timer_0(T0_DIV_1); 
0212:  MOVLW  88
0214:  MOVWF  FD5
0216:  GOTO   1A2C (RETURN)
.................... } 
....................  
.................... void start_alert() 
.................... { 
....................    setup_ccp1(CCP_PWM); 
*
0242:  BCF    F94.2
0244:  BCF    F8B.2
0246:  MOVLW  0C
0248:  MOVWF  FBD
....................    setup_timer_2(T2_DIV_BY_16, 200, 1); 
024A:  MOVLW  00
024C:  IORLW  06
024E:  MOVWF  FCA
0250:  MOVLW  C8
0252:  MOVWF  FCB
....................    output_low(PIN_C1); //ccp2 
0254:  BCF    F94.1
0256:  BCF    F8B.1
....................    setup_ccp2(CCP_PWM); 
0258:  BCF    F94.1
025A:  BCF    F8B.1
025C:  MOVLW  0C
025E:  MOVWF  FBA
....................    set_pwm2_duty(190);         
0260:  MOVLW  BE
0262:  MOVWF  FBB
....................    delay_ms(100); 
0264:  MOVLW  64
0266:  MOVLB  2
0268:  MOVWF  x81
026A:  MOVLB  0
026C:  RCALL  021A
....................    set_pwm2_duty(0);       
026E:  CLRF   FBB
....................    delay_ms(40); 
0270:  MOVLW  28
0272:  MOVLB  2
0274:  MOVWF  x81
0276:  MOVLB  0
0278:  RCALL  021A
....................    set_pwm2_duty(100);       
027A:  MOVLW  64
027C:  MOVWF  FBB
....................    delay_ms(100); 
027E:  MOVLB  2
0280:  MOVWF  x81
0282:  MOVLB  0
0284:  RCALL  021A
....................    set_pwm2_duty(0); 
0286:  CLRF   FBB
....................    output_low(PIN_C1); //CCP2 
0288:  BCF    F94.1
028A:  BCF    F8B.1
028C:  GOTO   1A30 (RETURN)
.................... } 
....................  
.................... void Motor1_Start() 
0290:  MOVLW  64
0292:  MOVLB  2
0294:  MOVWF  x66
.................... { 
....................    int duty = 100; 
....................  
....................    output_low(PIN_C2); //CCP1 
0296:  BCF    F94.2
0298:  BCF    F8B.2
....................    setup_ccp1(CCP_PWM); 
029A:  BCF    F94.2
029C:  BCF    F8B.2
029E:  MOVLW  0C
02A0:  MOVWF  FBD
....................    setup_timer_2(T2_DIV_BY_16, 255, 1); 
02A2:  MOVLW  00
02A4:  IORLW  06
02A6:  MOVWF  FCA
02A8:  MOVLW  FF
02AA:  MOVWF  FCB
....................    set_pwm1_duty(duty);         
02AC:  MOVFF  266,FBE
....................    delay_ms(250); 
02B0:  MOVLW  FA
02B2:  MOVWF  x81
02B4:  MOVLB  0
02B6:  RCALL  021A
....................    duty = 0; 
02B8:  MOVLB  2
02BA:  CLRF   x66
....................    set_pwm1_duty(duty);       
02BC:  MOVFF  266,FBE
....................    delay_ms(80); 
02C0:  MOVLW  50
02C2:  MOVWF  x81
02C4:  MOVLB  0
02C6:  RCALL  021A
....................    duty = 200; 
02C8:  MOVLW  C8
02CA:  MOVLB  2
02CC:  MOVWF  x66
....................    set_pwm1_duty(duty);       
02CE:  MOVFF  266,FBE
....................    delay_ms(200); 
02D2:  MOVWF  x81
02D4:  MOVLB  0
02D6:  RCALL  021A
....................    duty = 0; 
02D8:  MOVLB  2
02DA:  CLRF   x66
....................    set_pwm1_duty(duty);     
02DC:  MOVFF  266,FBE
....................    output_low(PIN_C2); //CCP1 
02E0:  BCF    F94.2
02E2:  BCF    F8B.2
02E4:  MOVLB  0
02E6:  GOTO   1A34 (RETURN)
.................... } 
....................  
.................... void If_Message(VOID) 
.................... { 
....................    char _Cel1[8], _Cel2[8]; 
....................  
....................    for (INT indexM = 0; indexM < 5; IndexM++) 
*
169C:  MOVLB  2
169E:  CLRF   x76
16A0:  MOVF   x76,W
16A2:  SUBLW  04
16A4:  BNC   1702
....................    { 
....................       _Cel1[indexM] = read_eeprom (indexM + 25); 
16A6:  CLRF   03
16A8:  MOVF   x76,W
16AA:  ADDLW  66
16AC:  MOVWF  FE9
16AE:  MOVLW  02
16B0:  ADDWFC 03,W
16B2:  MOVWF  FEA
16B4:  MOVLW  19
16B6:  ADDWF  x76,W
16B8:  MOVWF  x82
16BA:  MOVFF  FF2,283
16BE:  BCF    FF2.7
16C0:  MOVFF  282,FA9
16C4:  BCF    FA6.6
16C6:  BCF    FA6.7
16C8:  BSF    FA6.0
16CA:  MOVF   FA8,W
16CC:  BTFSC  x83.7
16CE:  BSF    FF2.7
16D0:  MOVWF  FEF
....................       _Cel2[indexM] = read_eeprom (indexM + 30); 
16D2:  CLRF   03
16D4:  MOVF   x76,W
16D6:  ADDLW  6E
16D8:  MOVWF  FE9
16DA:  MOVLW  02
16DC:  ADDWFC 03,W
16DE:  MOVWF  FEA
16E0:  MOVLW  1E
16E2:  ADDWF  x76,W
16E4:  MOVWF  x82
16E6:  MOVFF  FF2,283
16EA:  BCF    FF2.7
16EC:  MOVFF  282,FA9
16F0:  BCF    FA6.6
16F2:  BCF    FA6.7
16F4:  BSF    FA6.0
16F6:  MOVF   FA8,W
16F8:  BTFSC  x83.7
16FA:  BSF    FF2.7
16FC:  MOVWF  FEF
16FE:  INCF   x76,F
1700:  BRA    16A0
....................    } 
....................  
....................    float Num1 = atof (_Cel1); 
....................    float Num2 = atof (_Cel2); 
1702:  MOVLW  02
1704:  MOVWF  x85
1706:  MOVLW  66
1708:  MOVWF  x84
170A:  CLRF   x87
170C:  CLRF   x86
170E:  MOVLB  0
1710:  CALL   096E
1714:  MOVFF  03,27A
1718:  MOVFF  02,279
171C:  MOVFF  01,278
1720:  MOVFF  00,277
1724:  MOVLW  02
1726:  MOVLB  2
1728:  MOVWF  x85
172A:  MOVLW  6E
172C:  MOVWF  x84
172E:  CLRF   x87
1730:  CLRF   x86
1732:  MOVLB  0
1734:  CALL   096E
1738:  MOVFF  03,27E
173C:  MOVFF  02,27D
1740:  MOVFF  01,27C
1744:  MOVFF  00,27B
....................     
....................    for (int index = 1; index < 10; index++) 
1748:  MOVLW  01
174A:  MOVLB  2
174C:  MOVWF  x7F
174E:  MOVF   x7F,W
1750:  SUBLW  09
1752:  BNC   17AE
....................    { 
....................       LatRead[index - 1] = read_eeprom(index); 
1754:  MOVLW  01
1756:  SUBWF  x7F,W
1758:  CLRF   03
175A:  ADDLW  22
175C:  MOVWF  FE9
175E:  MOVLW  00
1760:  ADDWFC 03,W
1762:  MOVWF  FEA
1764:  MOVFF  FF2,282
1768:  BCF    FF2.7
176A:  MOVFF  27F,FA9
176E:  BCF    FA6.6
1770:  BCF    FA6.7
1772:  BSF    FA6.0
1774:  MOVF   FA8,W
1776:  BTFSC  x82.7
1778:  BSF    FF2.7
177A:  MOVWF  FEF
....................       LonRead[index - 1] = read_eeprom(index + 10); 
177C:  MOVLW  01
177E:  SUBWF  x7F,W
1780:  CLRF   03
1782:  ADDLW  2C
1784:  MOVWF  FE9
1786:  MOVLW  00
1788:  ADDWFC 03,W
178A:  MOVWF  FEA
178C:  MOVLW  0A
178E:  ADDWF  x7F,W
1790:  MOVWF  x82
1792:  MOVFF  FF2,283
1796:  BCF    FF2.7
1798:  MOVFF  282,FA9
179C:  BCF    FA6.6
179E:  BCF    FA6.7
17A0:  BSF    FA6.0
17A2:  MOVF   FA8,W
17A4:  BTFSC  x83.7
17A6:  BSF    FF2.7
17A8:  MOVWF  FEF
17AA:  INCF   x7F,F
17AC:  BRA    174E
....................    } 
....................     
....................    if (Send_Message) 
17AE:  BSF    F93.0
17B0:  BTFSS  F81.0
17B2:  BRA    1908
....................    { 
....................       set_pwm2_duty(5);    
17B4:  MOVLW  05
17B6:  MOVWF  FBB
....................       output_high(pin_a4); 
17B8:  BCF    F92.4
17BA:  BSF    F89.4
....................       printf ("AT+CMGF=1\r") ; 
17BC:  MOVLW  9C
17BE:  MOVWF  FF6
17C0:  MOVLW  01
17C2:  MOVWF  FF7
17C4:  MOVLB  0
17C6:  BRA    14A8
....................       delay_ms(10); 
17C8:  MOVLW  0A
17CA:  MOVLB  2
17CC:  MOVWF  x81
17CE:  MOVLB  0
17D0:  CALL   021A
....................       printf("AT+CMGS=\"+52%.0f%.0f\"\r",Num1,Num2); 
17D4:  MOVLW  A8
17D6:  MOVWF  FF6
17D8:  MOVLW  01
17DA:  MOVWF  FF7
17DC:  MOVLW  0C
17DE:  MOVLB  2
17E0:  MOVWF  x88
17E2:  MOVLB  0
17E4:  RCALL  14CC
17E6:  MOVLW  89
17E8:  MOVWF  FE9
17EA:  MOVFF  27A,28B
17EE:  MOVFF  279,28A
17F2:  MOVFF  278,289
17F6:  MOVFF  277,288
17FA:  MOVLB  2
17FC:  CLRF   x8C
17FE:  MOVLB  0
1800:  RCALL  14F6
1802:  MOVLW  89
1804:  MOVWF  FE9
1806:  MOVFF  27E,28B
180A:  MOVFF  27D,28A
180E:  MOVFF  27C,289
1812:  MOVFF  27B,288
1816:  MOVLB  2
1818:  CLRF   x8C
181A:  MOVLB  0
181C:  RCALL  14F6
181E:  MOVLW  22
1820:  BTFSS  F9E.4
1822:  BRA    1820
1824:  MOVWF  FAD
1826:  MOVLW  0D
1828:  BTFSS  F9E.4
182A:  BRA    1828
182C:  MOVWF  FAD
....................       //printf("AT+CMGS=\"+52%.0f%.0f\"\r",Num1,Num2); 
....................       delay_ms(10); 
182E:  MOVLW  0A
1830:  MOVLB  2
1832:  MOVWF  x81
1834:  MOVLB  0
1836:  CALL   021A
....................       printf("https://maps.google.com/?q=%.6f,-%.6f\x1a\r",atof(LatRead),atof(LonRead)); 
183A:  MOVLB  2
183C:  CLRF   x85
183E:  MOVLW  22
1840:  MOVWF  x84
1842:  CLRF   x87
1844:  CLRF   x86
1846:  MOVLB  0
1848:  CALL   096E
184C:  MOVFF  03,283
1850:  MOVFF  02,282
1854:  MOVFF  01,281
1858:  MOVFF  00,280
185C:  MOVLB  2
185E:  CLRF   x85
1860:  MOVLW  2C
1862:  MOVWF  x84
1864:  CLRF   x87
1866:  CLRF   x86
1868:  MOVLB  0
186A:  CALL   096E
186E:  MOVFF  03,287
1872:  MOVFF  02,286
1876:  MOVFF  01,285
187A:  MOVFF  00,284
187E:  MOVLW  C0
1880:  MOVWF  FF6
1882:  MOVLW  01
1884:  MOVWF  FF7
1886:  MOVLW  1B
1888:  MOVLB  2
188A:  MOVWF  x88
188C:  MOVLB  0
188E:  RCALL  14CC
1890:  MOVLW  89
1892:  MOVWF  FE9
1894:  MOVFF  283,28B
1898:  MOVFF  282,28A
189C:  MOVFF  281,289
18A0:  MOVFF  280,288
18A4:  MOVLW  06
18A6:  MOVLB  2
18A8:  MOVWF  x8C
18AA:  MOVLB  0
18AC:  RCALL  14F6
18AE:  MOVLW  2C
18B0:  BTFSS  F9E.4
18B2:  BRA    18B0
18B4:  MOVWF  FAD
18B6:  MOVLW  2D
18B8:  BTFSS  F9E.4
18BA:  BRA    18B8
18BC:  MOVWF  FAD
18BE:  MOVLW  89
18C0:  MOVWF  FE9
18C2:  MOVFF  287,28B
18C6:  MOVFF  286,28A
18CA:  MOVFF  285,289
18CE:  MOVFF  284,288
18D2:  MOVLW  06
18D4:  MOVLB  2
18D6:  MOVWF  x8C
18D8:  MOVLB  0
18DA:  RCALL  14F6
18DC:  MOVLW  1A
18DE:  BTFSS  F9E.4
18E0:  BRA    18DE
18E2:  MOVWF  FAD
18E4:  MOVLW  0D
18E6:  BTFSS  F9E.4
18E8:  BRA    18E6
18EA:  MOVWF  FAD
....................       delay_ms(1500); 
18EC:  MOVLW  06
18EE:  MOVLB  2
18F0:  MOVWF  x80
18F2:  MOVLW  FA
18F4:  MOVWF  x81
18F6:  MOVLB  0
18F8:  CALL   021A
18FC:  MOVLB  2
18FE:  DECFSZ x80,F
1900:  BRA    18F2
....................       set_pwm2_duty(0); 
1902:  CLRF   FBB
....................       output_low(pin_a4); 
1904:  BCF    F92.4
1906:  BCF    F89.4
....................    } 
1908:  MOVLB  0
190A:  GOTO   1A70 (RETURN)
.................... } 
....................  
.................... void process_tel_number() 
.................... { 
....................    if(1 == str_flag2) 
190E:  MOVLB  2
1910:  DECFSZ x5C,W
1912:  BRA    19BA
....................    { 
....................       if(str[1]=='@') 
1914:  MOVF   5D,W
1916:  SUBLW  40
1918:  BNZ   19BA
....................             { 
....................                set_pwm2_duty(150); // Beep when a telephone number is configured 
191A:  MOVLW  96
191C:  MOVWF  FBB
....................                delay_ms(40); 
191E:  MOVLW  28
1920:  MOVWF  x81
1922:  MOVLB  0
1924:  CALL   021A
....................                set_pwm2_duty(0);   // End beep 
1928:  CLRF   FBB
....................                delay_ms(40); 
192A:  MOVLW  28
192C:  MOVLB  2
192E:  MOVWF  x81
1930:  MOVLB  0
1932:  CALL   021A
....................                set_pwm2_duty(150); // Beep when a telephone number is configured 
1936:  MOVLW  96
1938:  MOVWF  FBB
....................                delay_ms(40); 
193A:  MOVLW  28
193C:  MOVLB  2
193E:  MOVWF  x81
1940:  MOVLB  0
1942:  CALL   021A
....................                set_pwm2_duty(0);   // End beep 
1946:  CLRF   FBB
....................                delay_ms(40); 
1948:  MOVLW  28
194A:  MOVLB  2
194C:  MOVWF  x81
194E:  MOVLB  0
1950:  CALL   021A
....................                set_pwm2_duty(150); // Beep when a telephone number is configured 
1954:  MOVLW  96
1956:  MOVWF  FBB
....................                delay_ms(40); 
1958:  MOVLW  28
195A:  MOVLB  2
195C:  MOVWF  x81
195E:  MOVLB  0
1960:  CALL   021A
....................                set_pwm2_duty(0);   // End beep 
1964:  CLRF   FBB
....................                for(int index = 0; index < 10; index++) 
1966:  MOVLB  2
1968:  CLRF   x66
196A:  MOVF   x66,W
196C:  SUBLW  09
196E:  BNC   19BA
....................                { 
....................                    write_eeprom(index + 25, str[index + 2]); 
1970:  MOVLW  19
1972:  ADDWF  x66,W
1974:  MOVWF  x67
1976:  MOVLW  02
1978:  ADDWF  x66,W
197A:  CLRF   03
197C:  ADDLW  5C
197E:  MOVWF  FE9
1980:  MOVLW  00
1982:  ADDWFC 03,W
1984:  MOVWF  FEA
1986:  MOVFF  FEF,268
198A:  MOVF   FF2,W
198C:  MOVWF  00
198E:  BCF    FF2.7
1990:  MOVFF  267,FA9
1994:  MOVFF  268,FA8
1998:  BCF    FA6.6
199A:  BCF    FA6.7
199C:  BSF    FA6.2
199E:  MOVLB  F
19A0:  MOVLW  55
19A2:  MOVWF  FA7
19A4:  MOVLW  AA
19A6:  MOVWF  FA7
19A8:  BSF    FA6.1
19AA:  BTFSC  FA6.1
19AC:  BRA    19AA
19AE:  BCF    FA6.2
19B0:  MOVF   00,W
19B2:  IORWF  FF2,F
19B4:  MOVLB  2
19B6:  INCF   x66,F
19B8:  BRA    196A
....................                } 
....................             } 
....................    } 
....................    str_flag2 = 0; 
19BA:  CLRF   x5C
19BC:  MOVLB  0
19BE:  GOTO   1A72 (RETURN)
.................... } 
....................  
.................... void Get_GPS(void) 
.................... { 
....................    char lat[9], lg[10]; 
....................  
....................    if ( (str_flag == 1 ) && (savePosition == 1) ) 
*
0BBA:  MOVLB  2
0BBC:  DECFSZ x5A,W
0BBE:  BRA    0C92
0BC0:  DECFSZ 36,W
0BC2:  BRA    0C92
....................    { 
....................       ///////////////////// Si el str[4] == G obtenemos de la trama los valores de la latitud 
....................       if (str[4] == 'G') 
0BC4:  MOVLB  0
0BC6:  MOVF   x60,W
0BC8:  SUBLW  47
0BCA:  BNZ   0C2C
....................       { 
....................          for (INT index = 0; index < 9; index++) 
0BCC:  MOVLB  2
0BCE:  CLRF   x79
0BD0:  MOVF   x79,W
0BD2:  SUBLW  08
0BD4:  BNC   0C0A
....................          { 
....................             lat[index] = str[index + 18]; 
0BD6:  CLRF   03
0BD8:  MOVF   x79,W
0BDA:  ADDLW  66
0BDC:  MOVWF  01
0BDE:  MOVLW  02
0BE0:  ADDWFC 03,F
0BE2:  MOVFF  03,27C
0BE6:  MOVLW  12
0BE8:  ADDWF  x79,W
0BEA:  CLRF   03
0BEC:  ADDLW  5C
0BEE:  MOVWF  FE9
0BF0:  MOVLW  00
0BF2:  ADDWFC 03,W
0BF4:  MOVWF  FEA
0BF6:  MOVFF  FEF,27D
0BFA:  MOVFF  27C,FEA
0BFE:  MOVFF  01,FE9
0C02:  MOVFF  27D,FEF
0C06:  INCF   x79,F
0C08:  BRA    0BD0
....................          } 
....................  
....................          latitud = atof (lat); 
0C0A:  MOVLW  02
0C0C:  MOVWF  x85
0C0E:  MOVLW  66
0C10:  MOVWF  x84
0C12:  CLRF   x87
0C14:  CLRF   x86
0C16:  MOVLB  0
0C18:  RCALL  096E
0C1A:  MOVFF  03,3B
0C1E:  MOVFF  02,3A
0C22:  MOVFF  01,39
0C26:  MOVFF  00,38
....................         // output_toggle (pin_a4); 
....................       } 
0C2A:  BRA    0C90
....................  
....................       /////////////////// Cuando str[4] = M obtenemos de la trama los valores de longitud en string 
....................       else if (str[4] == 'M') 
0C2C:  MOVF   x60,W
0C2E:  SUBLW  4D
0C30:  BNZ   0C90
....................       { 
....................          for (INT index = 0; index < 10; index++) 
0C32:  MOVLB  2
0C34:  CLRF   x7A
0C36:  MOVF   x7A,W
0C38:  SUBLW  09
0C3A:  BNC   0C70
....................          { 
....................             lg[index] = str[index + 32]; 
0C3C:  CLRF   03
0C3E:  MOVF   x7A,W
0C40:  ADDLW  6F
0C42:  MOVWF  01
0C44:  MOVLW  02
0C46:  ADDWFC 03,F
0C48:  MOVFF  03,27C
0C4C:  MOVLW  20
0C4E:  ADDWF  x7A,W
0C50:  CLRF   03
0C52:  ADDLW  5C
0C54:  MOVWF  FE9
0C56:  MOVLW  00
0C58:  ADDWFC 03,W
0C5A:  MOVWF  FEA
0C5C:  MOVFF  FEF,27D
0C60:  MOVFF  27C,FEA
0C64:  MOVFF  01,FE9
0C68:  MOVFF  27D,FEF
0C6C:  INCF   x7A,F
0C6E:  BRA    0C36
....................          } 
....................  
....................          longitud = atof (lg); 
0C70:  MOVLW  02
0C72:  MOVWF  x85
0C74:  MOVLW  6F
0C76:  MOVWF  x84
0C78:  CLRF   x87
0C7A:  CLRF   x86
0C7C:  MOVLB  0
0C7E:  RCALL  096E
0C80:  MOVFF  03,3F
0C84:  MOVFF  02,3E
0C88:  MOVFF  01,3D
0C8C:  MOVFF  00,3C
0C90:  MOVLB  2
....................       } 
....................    } 
....................  
....................    str_flag = 0; 
0C92:  CLRF   x5A
0C94:  MOVLB  0
0C96:  GOTO   1A6A (RETURN)
.................... } 
....................  
.................... void gps_info_processor(void) 
.................... { 
....................    // Alert that GPS is Connected/Disconnected 
....................       // NOTE: Change set_pwm1_duty to set_pwm2_duty when buzzer works properly 
....................       if( (latitud > 0.5) && (GPS_Connected == 0) ) 
*
0FB2:  MOVLB  2
0FB4:  CLRF   x6A
0FB6:  CLRF   x69
0FB8:  CLRF   x68
0FBA:  MOVLW  7E
0FBC:  MOVWF  x67
0FBE:  MOVFF  3B,26E
0FC2:  MOVFF  3A,26D
0FC6:  MOVFF  39,26C
0FCA:  MOVFF  38,26B
0FCE:  MOVLB  0
0FD0:  RCALL  0C9A
0FD2:  BNC   102C
0FD4:  MOVF   37,F
0FD6:  BNZ   102C
....................       { 
....................         //GPS Connected 
....................         set_pwm2_duty(130);         
0FD8:  MOVLW  82
0FDA:  MOVWF  FBB
....................         delay_ms(100); 
0FDC:  MOVLW  64
0FDE:  MOVLB  2
0FE0:  MOVWF  x81
0FE2:  MOVLB  0
0FE4:  CALL   021A
....................         set_pwm2_duty(0);  
0FE8:  CLRF   FBB
....................         delay_ms(20); 
0FEA:  MOVLW  14
0FEC:  MOVLB  2
0FEE:  MOVWF  x81
0FF0:  MOVLB  0
0FF2:  CALL   021A
....................         set_pwm2_duty(130);         
0FF6:  MOVLW  82
0FF8:  MOVWF  FBB
....................         delay_ms(100); 
0FFA:  MOVLW  64
0FFC:  MOVLB  2
0FFE:  MOVWF  x81
1000:  MOVLB  0
1002:  CALL   021A
....................         set_pwm2_duty(0);  
1006:  CLRF   FBB
....................         delay_ms(20); 
1008:  MOVLW  14
100A:  MOVLB  2
100C:  MOVWF  x81
100E:  MOVLB  0
1010:  CALL   021A
....................         set_pwm2_duty(130);         
1014:  MOVLW  82
1016:  MOVWF  FBB
....................         delay_ms(100); 
1018:  MOVLW  64
101A:  MOVLB  2
101C:  MOVWF  x81
101E:  MOVLB  0
1020:  CALL   021A
....................         set_pwm2_duty(0);  
1024:  CLRF   FBB
....................         GPS_Connected = 1; 
1026:  MOVLW  01
1028:  MOVWF  37
....................       } 
102A:  BRA    1072
....................       else if( (latitud < 0.5) && (GPS_Connected == 1) ) 
102C:  MOVFF  3B,26A
1030:  MOVFF  3A,269
1034:  MOVFF  39,268
1038:  MOVFF  38,267
103C:  MOVLB  2
103E:  CLRF   x6E
1040:  CLRF   x6D
1042:  CLRF   x6C
1044:  MOVLW  7E
1046:  MOVWF  x6B
1048:  MOVLB  0
104A:  RCALL  0C9A
104C:  BNC   1072
104E:  DECFSZ 37,W
1050:  BRA    1072
....................       { 
....................       //GPS Disconnected 
....................         set_pwm2_duty(80);         
1052:  MOVLW  50
1054:  MOVWF  FBB
....................         delay_ms(500); 
1056:  MOVLW  02
1058:  MOVLB  2
105A:  MOVWF  x67
105C:  MOVLW  FA
105E:  MOVWF  x81
1060:  MOVLB  0
1062:  CALL   021A
1066:  MOVLB  2
1068:  DECFSZ x67,F
106A:  BRA    105C
....................         set_pwm2_duty(0); 
106C:  CLRF   FBB
....................         GPS_Connected = 0; 
106E:  CLRF   37
1070:  MOVLB  0
....................       } 
....................        
....................       // First store position into eeprom memory every 10 seconds 
....................       if( (savePosition == 1) && (GPS_Connected == 1) ) 
1072:  DECFSZ 36,W
1074:  BRA    14A2
1076:  DECFSZ 37,W
1078:  BRA    14A2
....................       { 
....................          // sprintf(LatWrite,"%.6f",latitud*0.01); 
....................          // sprintf(LonWrite,"%.6f",longitud*0.01); 
....................          latitudConverted  = (float) ( (int8) (latitud * 0.01)  + (float) (((latitud * 0.01)  - (int8) (latitud * 0.01))  / 60.0)*100 ); 
107A:  MOVFF  3B,298
107E:  MOVFF  3A,297
1082:  MOVFF  39,296
1086:  MOVFF  38,295
108A:  MOVLW  0A
108C:  MOVLB  2
108E:  MOVWF  x9C
1090:  MOVLW  D7
1092:  MOVWF  x9B
1094:  MOVLW  23
1096:  MOVWF  x9A
1098:  MOVLW  78
109A:  MOVWF  x99
109C:  MOVLB  0
109E:  CALL   0320
10A2:  MOVFF  03,26F
10A6:  MOVFF  02,26E
10AA:  MOVFF  01,26D
10AE:  MOVFF  00,26C
10B2:  CALL   068E
10B6:  MOVFF  01,267
10BA:  MOVFF  3B,298
10BE:  MOVFF  3A,297
10C2:  MOVFF  39,296
10C6:  MOVFF  38,295
10CA:  MOVLW  0A
10CC:  MOVLB  2
10CE:  MOVWF  x9C
10D0:  MOVLW  D7
10D2:  MOVWF  x9B
10D4:  MOVLW  23
10D6:  MOVWF  x9A
10D8:  MOVLW  78
10DA:  MOVWF  x99
10DC:  MOVLB  0
10DE:  CALL   0320
10E2:  MOVFF  03,26B
10E6:  MOVFF  02,26A
10EA:  MOVFF  01,269
10EE:  MOVFF  00,268
10F2:  MOVFF  3B,298
10F6:  MOVFF  3A,297
10FA:  MOVFF  39,296
10FE:  MOVFF  38,295
1102:  MOVLW  0A
1104:  MOVLB  2
1106:  MOVWF  x9C
1108:  MOVLW  D7
110A:  MOVWF  x9B
110C:  MOVLW  23
110E:  MOVWF  x9A
1110:  MOVLW  78
1112:  MOVWF  x99
1114:  MOVLB  0
1116:  CALL   0320
111A:  MOVFF  03,26F
111E:  MOVFF  02,26E
1122:  MOVFF  01,26D
1126:  MOVFF  00,26C
112A:  CALL   068E
112E:  MOVLB  2
1130:  CLRF   x98
1132:  MOVFF  01,297
1136:  MOVLB  0
1138:  CALL   02EA
113C:  BSF    FD8.1
113E:  MOVFF  26B,29A
1142:  MOVFF  26A,299
1146:  MOVFF  269,298
114A:  MOVFF  268,297
114E:  MOVFF  03,29E
1152:  MOVFF  02,29D
1156:  MOVFF  01,29C
115A:  MOVFF  00,29B
115E:  CALL   0416
1162:  MOVFF  03,26B
1166:  MOVFF  02,26A
116A:  MOVFF  01,269
116E:  MOVFF  00,268
1172:  MOVFF  03,29A
1176:  MOVFF  02,299
117A:  MOVFF  01,298
117E:  MOVFF  00,297
1182:  MOVLB  2
1184:  CLRF   x9E
1186:  CLRF   x9D
1188:  MOVLW  70
118A:  MOVWF  x9C
118C:  MOVLW  84
118E:  MOVWF  x9B
1190:  MOVLB  0
1192:  CALL   06CA
1196:  MOVFF  03,26B
119A:  MOVFF  02,26A
119E:  MOVFF  01,269
11A2:  MOVFF  00,268
11A6:  MOVFF  03,298
11AA:  MOVFF  02,297
11AE:  MOVFF  01,296
11B2:  MOVFF  00,295
11B6:  MOVLB  2
11B8:  CLRF   x9C
11BA:  CLRF   x9B
11BC:  MOVLW  48
11BE:  MOVWF  x9A
11C0:  MOVLW  85
11C2:  MOVWF  x99
11C4:  MOVLB  0
11C6:  CALL   0320
11CA:  MOVFF  03,26B
11CE:  MOVFF  02,26A
11D2:  MOVFF  01,269
11D6:  MOVFF  00,268
11DA:  MOVLB  2
11DC:  CLRF   x98
11DE:  MOVFF  267,297
11E2:  MOVLB  0
11E4:  CALL   02EA
11E8:  BCF    FD8.1
11EA:  MOVFF  03,29A
11EE:  MOVFF  02,299
11F2:  MOVFF  01,298
11F6:  MOVFF  00,297
11FA:  MOVFF  26B,29E
11FE:  MOVFF  26A,29D
1202:  MOVFF  269,29C
1206:  MOVFF  268,29B
120A:  CALL   0416
120E:  MOVFF  03,57
1212:  MOVFF  02,56
1216:  MOVFF  01,55
121A:  MOVFF  00,54
....................          longitudConverted = (float) ( (int8) (longitud * 0.01) + (float) (((longitud * 0.01) - (int8) (longitud * 0.01)) / 60.0)*100 ); 
121E:  MOVFF  3F,298
1222:  MOVFF  3E,297
1226:  MOVFF  3D,296
122A:  MOVFF  3C,295
122E:  MOVLW  0A
1230:  MOVLB  2
1232:  MOVWF  x9C
1234:  MOVLW  D7
1236:  MOVWF  x9B
1238:  MOVLW  23
123A:  MOVWF  x9A
123C:  MOVLW  78
123E:  MOVWF  x99
1240:  MOVLB  0
1242:  CALL   0320
1246:  MOVFF  03,26F
124A:  MOVFF  02,26E
124E:  MOVFF  01,26D
1252:  MOVFF  00,26C
1256:  CALL   068E
125A:  MOVFF  01,267
125E:  MOVFF  3F,298
1262:  MOVFF  3E,297
1266:  MOVFF  3D,296
126A:  MOVFF  3C,295
126E:  MOVLW  0A
1270:  MOVLB  2
1272:  MOVWF  x9C
1274:  MOVLW  D7
1276:  MOVWF  x9B
1278:  MOVLW  23
127A:  MOVWF  x9A
127C:  MOVLW  78
127E:  MOVWF  x99
1280:  MOVLB  0
1282:  CALL   0320
1286:  MOVFF  03,26B
128A:  MOVFF  02,26A
128E:  MOVFF  01,269
1292:  MOVFF  00,268
1296:  MOVFF  3F,298
129A:  MOVFF  3E,297
129E:  MOVFF  3D,296
12A2:  MOVFF  3C,295
12A6:  MOVLW  0A
12A8:  MOVLB  2
12AA:  MOVWF  x9C
12AC:  MOVLW  D7
12AE:  MOVWF  x9B
12B0:  MOVLW  23
12B2:  MOVWF  x9A
12B4:  MOVLW  78
12B6:  MOVWF  x99
12B8:  MOVLB  0
12BA:  CALL   0320
12BE:  MOVFF  03,26F
12C2:  MOVFF  02,26E
12C6:  MOVFF  01,26D
12CA:  MOVFF  00,26C
12CE:  CALL   068E
12D2:  MOVLB  2
12D4:  CLRF   x98
12D6:  MOVFF  01,297
12DA:  MOVLB  0
12DC:  CALL   02EA
12E0:  BSF    FD8.1
12E2:  MOVFF  26B,29A
12E6:  MOVFF  26A,299
12EA:  MOVFF  269,298
12EE:  MOVFF  268,297
12F2:  MOVFF  03,29E
12F6:  MOVFF  02,29D
12FA:  MOVFF  01,29C
12FE:  MOVFF  00,29B
1302:  CALL   0416
1306:  MOVFF  03,26B
130A:  MOVFF  02,26A
130E:  MOVFF  01,269
1312:  MOVFF  00,268
1316:  MOVFF  03,29A
131A:  MOVFF  02,299
131E:  MOVFF  01,298
1322:  MOVFF  00,297
1326:  MOVLB  2
1328:  CLRF   x9E
132A:  CLRF   x9D
132C:  MOVLW  70
132E:  MOVWF  x9C
1330:  MOVLW  84
1332:  MOVWF  x9B
1334:  MOVLB  0
1336:  CALL   06CA
133A:  MOVFF  03,26B
133E:  MOVFF  02,26A
1342:  MOVFF  01,269
1346:  MOVFF  00,268
134A:  MOVFF  03,298
134E:  MOVFF  02,297
1352:  MOVFF  01,296
1356:  MOVFF  00,295
135A:  MOVLB  2
135C:  CLRF   x9C
135E:  CLRF   x9B
1360:  MOVLW  48
1362:  MOVWF  x9A
1364:  MOVLW  85
1366:  MOVWF  x99
1368:  MOVLB  0
136A:  CALL   0320
136E:  MOVFF  03,26B
1372:  MOVFF  02,26A
1376:  MOVFF  01,269
137A:  MOVFF  00,268
137E:  MOVLB  2
1380:  CLRF   x98
1382:  MOVFF  267,297
1386:  MOVLB  0
1388:  CALL   02EA
138C:  BCF    FD8.1
138E:  MOVFF  03,29A
1392:  MOVFF  02,299
1396:  MOVFF  01,298
139A:  MOVFF  00,297
139E:  MOVFF  26B,29E
13A2:  MOVFF  26A,29D
13A6:  MOVFF  269,29C
13AA:  MOVFF  268,29B
13AE:  CALL   0416
13B2:  MOVFF  03,5B
13B6:  MOVFF  02,5A
13BA:  MOVFF  01,59
13BE:  MOVFF  00,58
....................          sprintf(LatWrite,"%.6f", latitudConverted); 
13C2:  MOVLB  2
13C4:  CLRF   x63
13C6:  MOVLW  40
13C8:  MOVWF  x62
13CA:  MOVLW  89
13CC:  MOVWF  FE9
13CE:  MOVFF  57,26A
13D2:  MOVFF  56,269
13D6:  MOVFF  55,268
13DA:  MOVFF  54,267
13DE:  MOVLW  06
13E0:  MOVWF  x6B
13E2:  MOVLB  0
13E4:  RCALL  0E0A
....................          sprintf(LonWrite,"%.6f", longitudConverted); 
13E6:  MOVLB  2
13E8:  CLRF   x63
13EA:  MOVLW  4A
13EC:  MOVWF  x62
13EE:  MOVLW  89
13F0:  MOVWF  FE9
13F2:  MOVFF  5B,26A
13F6:  MOVFF  5A,269
13FA:  MOVFF  59,268
13FE:  MOVFF  58,267
1402:  MOVLW  06
1404:  MOVWF  x6B
1406:  MOVLB  0
1408:  RCALL  0E0A
....................          for(int index = 1; index < 10; index++) 
140A:  MOVLW  01
140C:  MOVLB  2
140E:  MOVWF  x66
1410:  MOVF   x66,W
1412:  SUBLW  09
1414:  BNC   14A0
....................          { 
....................             write_eeprom(index, LatWrite[index - 1]); 
1416:  MOVLW  01
1418:  SUBWF  x66,W
141A:  CLRF   03
141C:  ADDLW  40
141E:  MOVWF  FE9
1420:  MOVLW  00
1422:  ADDWFC 03,W
1424:  MOVWF  FEA
1426:  MOVFF  FEF,267
142A:  MOVF   FF2,W
142C:  MOVWF  00
142E:  BCF    FF2.7
1430:  MOVFF  266,FA9
1434:  MOVFF  267,FA8
1438:  BCF    FA6.6
143A:  BCF    FA6.7
143C:  BSF    FA6.2
143E:  MOVLB  F
1440:  MOVLW  55
1442:  MOVWF  FA7
1444:  MOVLW  AA
1446:  MOVWF  FA7
1448:  BSF    FA6.1
144A:  BTFSC  FA6.1
144C:  BRA    144A
144E:  BCF    FA6.2
1450:  MOVF   00,W
1452:  IORWF  FF2,F
....................             write_eeprom(index + 10, LonWrite[index - 1]); 
1454:  MOVLW  0A
1456:  MOVLB  2
1458:  ADDWF  x66,W
145A:  MOVWF  x67
145C:  MOVLW  01
145E:  SUBWF  x66,W
1460:  CLRF   03
1462:  ADDLW  4A
1464:  MOVWF  FE9
1466:  MOVLW  00
1468:  ADDWFC 03,W
146A:  MOVWF  FEA
146C:  MOVFF  FEF,268
1470:  MOVF   FF2,W
1472:  MOVWF  00
1474:  BCF    FF2.7
1476:  MOVFF  267,FA9
147A:  MOVFF  268,FA8
147E:  BCF    FA6.6
1480:  BCF    FA6.7
1482:  BSF    FA6.2
1484:  MOVLB  F
1486:  MOVLW  55
1488:  MOVWF  FA7
148A:  MOVLW  AA
148C:  MOVWF  FA7
148E:  BSF    FA6.1
1490:  BTFSC  FA6.1
1492:  BRA    1490
1494:  BCF    FA6.2
1496:  MOVF   00,W
1498:  IORWF  FF2,F
149A:  MOVLB  2
149C:  INCF   x66,F
149E:  BRA    1410
....................          } 
....................          savePosition = 0; 
14A0:  CLRF   36
14A2:  MOVLB  0
....................       } 
14A4:  GOTO   1A6E (RETURN)
.................... } 
....................  
.................... void dummyFunction(char characterRecived) 
.................... { 
....................    if (characterRecived == '$') 
*
00E6:  MOVLB  2
00E8:  MOVF   xA8,W
00EA:  SUBLW  24
00EC:  BNZ   00F4
....................    { 
....................       i = 0; 
00EE:  CLRF   x5D
....................       flag_buf = 1; 
00F0:  MOVLW  01
00F2:  MOVWF  x5B
....................    } 
....................  
....................    if (characterRecived == '<') 
00F4:  MOVF   xA8,W
00F6:  SUBLW  3C
00F8:  BNZ   0100
....................    { 
....................       i = 0; 
00FA:  CLRF   x5D
....................       flag_buf = 2; 
00FC:  MOVLW  02
00FE:  MOVWF  x5B
....................    } 
....................  
....................    if (flag_buf == 1) 
0100:  DECFSZ x5B,W
0102:  BRA    013E
....................    { 
....................       //recibimos un entero sin signo 
....................       if (characterRecived == 0x0d) 
0104:  MOVF   xA8,W
0106:  SUBLW  0D
0108:  BNZ   012A
....................       { 
....................          //si recibe un enter --- o un salto de linea 
....................          flag_buf = 0; 
010A:  CLRF   x5B
....................          str_flag = 1; //flag must be cleared by software 
010C:  MOVLW  01
010E:  MOVWF  x5A
....................          characterRecived = 0; //fin de la trama 
0110:  CLRF   xA8
....................          strcpy (str, buf); //copia en str lo que est en bufer 
0112:  CLRF   FEA
0114:  MOVLW  5C
0116:  MOVWF  FE9
0118:  MOVLW  01
011A:  MOVWF  FE2
011C:  MOVLW  5B
011E:  MOVWF  FE1
0120:  MOVF   FE7,F
0122:  MOVFF  FE6,FEE
0126:  BNZ   0120
....................       } 
0128:  BRA    013E
....................  
....................       else 
....................       { 
....................          buf[i] = characterRecived; 
012A:  CLRF   03
012C:  MOVF   x5D,W
012E:  ADDLW  5B
0130:  MOVWF  FE9
0132:  MOVLW  01
0134:  ADDWFC 03,W
0136:  MOVWF  FEA
0138:  MOVFF  2A8,FEF
....................          i++; 
013C:  INCF   x5D,F
....................       } 
....................    } 
....................  
....................    if (flag_buf == 2) 
013E:  MOVF   x5B,W
0140:  SUBLW  02
0142:  BNZ   017E
....................    { 
....................       if (characterRecived == '>') 
0144:  MOVF   xA8,W
0146:  SUBLW  3E
0148:  BNZ   016A
....................       { 
....................          flag_buf = 0; 
014A:  CLRF   x5B
....................          str_flag2 = 1; //flag must be cleared by software 
014C:  MOVLW  01
014E:  MOVWF  x5C
....................          characterRecived = 0; //fin de la trama 
0150:  CLRF   xA8
....................          strcpy (str, buf) ; 
0152:  CLRF   FEA
0154:  MOVLW  5C
0156:  MOVWF  FE9
0158:  MOVLW  01
015A:  MOVWF  FE2
015C:  MOVLW  5B
015E:  MOVWF  FE1
0160:  MOVF   FE7,F
0162:  MOVFF  FE6,FEE
0166:  BNZ   0160
....................       } 
0168:  BRA    017E
....................  
....................       else 
....................       { 
....................          buf[i] = characterRecived; 
016A:  CLRF   03
016C:  MOVF   x5D,W
016E:  ADDLW  5B
0170:  MOVWF  FE9
0172:  MOVLW  01
0174:  ADDWFC 03,W
0176:  MOVWF  FEA
0178:  MOVFF  2A8,FEF
....................          i++; 
017C:  INCF   x5D,F
....................       } 
....................    } 
017E:  MOVLB  0
0180:  GOTO   0196 (RETURN)
.................... } 
....................  
.................... int16 AdcReadAndProcessing() 
*
0828:  MOVLB  2
082A:  CLRF   x67
082C:  CLRF   x66
082E:  CLRF   x69
0830:  CLRF   x68
0832:  CLRF   x6B
0834:  CLRF   x6A
.................... { 
....................    int16 data_adc0 = 0, mmDistance = 0, distancePower = 0;  
....................  
....................    set_adc_channel(0); 
0836:  MOVLW  00
0838:  MOVWF  01
083A:  MOVF   FC2,W
083C:  ANDLW  C3
083E:  IORWF  01,W
0840:  MOVWF  FC2
....................    delay_us(20); 
0842:  MOVLW  0C
0844:  MOVWF  00
0846:  DECFSZ 00,F
0848:  BRA    0846
084A:  BRA    084C
084C:  NOP   
....................  
....................    data_adc0  = read_adc();     // 0 - 1024 bits 
084E:  BSF    FC2.1
0850:  BTFSC  FC2.1
0852:  BRA    0850
0854:  MOVFF  FC3,266
0858:  MOVFF  FC4,267
....................     
....................    if(data_adc0 > DISTANCE_LIMIT) 
085C:  MOVF   x67,W
085E:  SUBLW  01
0860:  BC    0872
0862:  XORLW  FF
0864:  BNZ   086C
0866:  MOVF   x66,W
0868:  SUBLW  00
086A:  BC    0872
....................    { 
....................       data_adc0 = DISTANCE_LIMIT; 
086C:  MOVLW  02
086E:  MOVWF  x67
0870:  CLRF   x66
....................    } 
....................     
....................    mmDistance = 7680 - ((data_adc0*2) * 5.0); // 0 - 2500mm 
0872:  BCF    FD8.0
0874:  RLCF   x66,W
0876:  MOVWF  x6C
0878:  RLCF   x67,W
087A:  MOVWF  x6D
087C:  MOVWF  x98
087E:  MOVFF  26C,297
0882:  MOVLB  0
0884:  RCALL  02EA
0886:  MOVFF  03,298
088A:  MOVFF  02,297
088E:  MOVFF  01,296
0892:  MOVFF  00,295
0896:  MOVLB  2
0898:  CLRF   x9C
089A:  CLRF   x9B
089C:  MOVLW  20
089E:  MOVWF  x9A
08A0:  MOVLW  81
08A2:  MOVWF  x99
08A4:  MOVLB  0
08A6:  RCALL  0320
08A8:  BSF    FD8.1
08AA:  MOVLB  2
08AC:  CLRF   x9A
08AE:  CLRF   x99
08B0:  MOVLW  70
08B2:  MOVWF  x98
08B4:  MOVLW  8B
08B6:  MOVWF  x97
08B8:  MOVFF  03,29E
08BC:  MOVFF  02,29D
08C0:  MOVFF  01,29C
08C4:  MOVFF  00,29B
08C8:  MOVLB  0
08CA:  RCALL  0416
08CC:  MOVFF  03,26F
08D0:  MOVFF  02,26E
08D4:  MOVFF  01,26D
08D8:  MOVFF  00,26C
08DC:  RCALL  068E
08DE:  MOVFF  02,269
08E2:  MOVFF  01,268
....................  
....................    voltage    = (mmDistance/(1000.0));  // convert distance to voltage, the higher the distance, the higher the voltage. 
08E6:  MOVFF  269,298
08EA:  MOVFF  268,297
08EE:  RCALL  02EA
08F0:  MOVFF  03,29A
08F4:  MOVFF  02,299
08F8:  MOVFF  01,298
08FC:  MOVFF  00,297
0900:  MOVLB  2
0902:  CLRF   x9E
0904:  CLRF   x9D
0906:  MOVLW  7A
0908:  MOVWF  x9C
090A:  MOVLW  88
090C:  MOVWF  x9B
090E:  MOVLB  0
0910:  RCALL  06CA
0912:  MOVFF  03,261
0916:  MOVFF  02,260
091A:  MOVFF  01,25F
091E:  MOVFF  00,25E
....................                                           // *2 due to we want the volteage to reach up to 5 volts 
....................     
....................    distancePower = (int16)(voltage * 49); 
0922:  MOVFF  261,298
0926:  MOVFF  260,297
092A:  MOVFF  25F,296
092E:  MOVFF  25E,295
0932:  MOVLB  2
0934:  CLRF   x9C
0936:  CLRF   x9B
0938:  MOVLW  44
093A:  MOVWF  x9A
093C:  MOVLW  84
093E:  MOVWF  x99
0940:  MOVLB  0
0942:  RCALL  0320
0944:  MOVFF  03,26F
0948:  MOVFF  02,26E
094C:  MOVFF  01,26D
0950:  MOVFF  00,26C
0954:  RCALL  068E
0956:  MOVFF  02,26B
095A:  MOVFF  01,26A
....................  
....................    return(distancePower); 
095E:  MOVLB  2
0960:  MOVFF  26A,01
0964:  MOVFF  26B,02
0968:  MOVLB  0
096A:  GOTO   1A38 (RETURN)
.................... } 

Configuration Fuses:
   Word  1: CF3F   PLL12 CPUDIV4 USBDIV FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
