CCS PCH C Compiler, Version 5.025, 12584               05-sep.-19 20:00

               Filename:   C:\Users\resen\SmartCane\Code\main.lst

               ROM used:   6770 bytes (21%)
                           Largest free fragment is 25994
               RAM used:   614 (30%) at main() level
                           683 (33%) worst case
               Stack used: 3 locations (2 in main + 1 for interrupts)
               Stack size: 31

*
0000:  GOTO   19B6
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   00BA
0060:  BTFSS  F9D.5
0062:  GOTO   006C
0066:  BTFSC  F9E.5
0068:  GOTO   0184
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include <18F2553.h> 
.................... //////////// Standard Header file for the PIC18F2553 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F2553 
*
019C:  DATA 41,54
019E:  DATA 2B,43
01A0:  DATA 4D,47
01A2:  DATA 46,3D
01A4:  DATA 31,0D
01A6:  DATA 00,00
01A8:  DATA 41,54
01AA:  DATA 2B,43
01AC:  DATA 4D,47
01AE:  DATA 53,3D
01B0:  DATA 22,2B
01B2:  DATA 35,32
01B4:  DATA 25,2E
01B6:  DATA 30,66
01B8:  DATA 25,2E
01BA:  DATA 30,66
01BC:  DATA 22,0D
01BE:  DATA 00,00
01C0:  DATA 68,74
01C2:  DATA 74,70
01C4:  DATA 73,3A
01C6:  DATA 2F,2F
01C8:  DATA 6D,61
01CA:  DATA 70,73
01CC:  DATA 2E,67
01CE:  DATA 6F,6F
01D0:  DATA 67,6C
01D2:  DATA 65,2E
01D4:  DATA 63,6F
01D6:  DATA 6D,2F
01D8:  DATA 3F,71
01DA:  DATA 3D,25
01DC:  DATA 2E,36
01DE:  DATA 66,2C
01E0:  DATA 2D,25
01E2:  DATA 2E,36
01E4:  DATA 66,1A
01E6:  DATA 0D,00
*
02EA:  MOVLW  8E
02EC:  MOVWF  00
02EE:  MOVFF  298,01
02F2:  MOVFF  297,02
02F6:  CLRF   03
02F8:  MOVF   01,F
02FA:  BNZ   030E
02FC:  MOVFF  02,01
0300:  CLRF   02
0302:  MOVLW  08
0304:  SUBWF  00,F
0306:  MOVF   01,F
0308:  BNZ   030E
030A:  CLRF   00
030C:  BRA    031E
030E:  BCF    FD8.0
0310:  BTFSC  01.7
0312:  BRA    031C
0314:  RLCF   02,F
0316:  RLCF   01,F
0318:  DECF   00,F
031A:  BRA    030E
031C:  BCF    01.7
031E:  RETURN 0
0320:  MOVLB  2
0322:  MOVF   x95,W
0324:  BTFSC  FD8.2
0326:  BRA    040A
0328:  MOVWF  00
032A:  MOVF   x99,W
032C:  BTFSC  FD8.2
032E:  BRA    040A
0330:  ADDWF  00,F
0332:  BNC   033C
0334:  MOVLW  81
0336:  ADDWF  00,F
0338:  BC    040A
033A:  BRA    0344
033C:  MOVLW  7F
033E:  SUBWF  00,F
0340:  BNC   040A
0342:  BZ    040A
0344:  MOVFF  296,29D
0348:  MOVF   x9A,W
034A:  XORWF  x9D,F
034C:  BSF    x96.7
034E:  BSF    x9A.7
0350:  MOVF   x98,W
0352:  MULWF  x9C
0354:  MOVFF  FF4,29F
0358:  MOVF   x97,W
035A:  MULWF  x9B
035C:  MOVFF  FF4,03
0360:  MOVFF  FF3,29E
0364:  MULWF  x9C
0366:  MOVF   FF3,W
0368:  ADDWF  x9F,F
036A:  MOVF   FF4,W
036C:  ADDWFC x9E,F
036E:  MOVLW  00
0370:  ADDWFC 03,F
0372:  MOVF   x98,W
0374:  MULWF  x9B
0376:  MOVF   FF3,W
0378:  ADDWF  x9F,F
037A:  MOVF   FF4,W
037C:  ADDWFC x9E,F
037E:  MOVLW  00
0380:  CLRF   02
0382:  ADDWFC 03,F
0384:  ADDWFC 02,F
0386:  MOVF   x96,W
0388:  MULWF  x9C
038A:  MOVF   FF3,W
038C:  ADDWF  x9E,F
038E:  MOVF   FF4,W
0390:  ADDWFC 03,F
0392:  MOVLW  00
0394:  ADDWFC 02,F
0396:  MOVF   x96,W
0398:  MULWF  x9B
039A:  MOVF   FF3,W
039C:  ADDWF  03,F
039E:  MOVF   FF4,W
03A0:  ADDWFC 02,F
03A2:  MOVLW  00
03A4:  CLRF   01
03A6:  ADDWFC 01,F
03A8:  MOVF   x98,W
03AA:  MULWF  x9A
03AC:  MOVF   FF3,W
03AE:  ADDWF  x9E,F
03B0:  MOVF   FF4,W
03B2:  ADDWFC 03,F
03B4:  MOVLW  00
03B6:  ADDWFC 02,F
03B8:  ADDWFC 01,F
03BA:  MOVF   x97,W
03BC:  MULWF  x9A
03BE:  MOVF   FF3,W
03C0:  ADDWF  03,F
03C2:  MOVF   FF4,W
03C4:  ADDWFC 02,F
03C6:  MOVLW  00
03C8:  ADDWFC 01,F
03CA:  MOVF   x96,W
03CC:  MULWF  x9A
03CE:  MOVF   FF3,W
03D0:  ADDWF  02,F
03D2:  MOVF   FF4,W
03D4:  ADDWFC 01,F
03D6:  INCF   00,F
03D8:  BTFSC  01.7
03DA:  BRA    03E6
03DC:  RLCF   x9E,F
03DE:  RLCF   03,F
03E0:  RLCF   02,F
03E2:  RLCF   01,F
03E4:  DECF   00,F
03E6:  MOVLW  00
03E8:  BTFSS  x9E.7
03EA:  BRA    0400
03EC:  INCF   03,F
03EE:  ADDWFC 02,F
03F0:  ADDWFC 01,F
03F2:  MOVF   01,W
03F4:  BNZ   0400
03F6:  MOVF   02,W
03F8:  BNZ   0400
03FA:  MOVF   03,W
03FC:  BNZ   0400
03FE:  INCF   00,F
0400:  BTFSC  x9D.7
0402:  BSF    01.7
0404:  BTFSS  x9D.7
0406:  BCF    01.7
0408:  BRA    0412
040A:  CLRF   00
040C:  CLRF   01
040E:  CLRF   02
0410:  CLRF   03
0412:  MOVLB  0
0414:  RETURN 0
0416:  MOVLW  80
0418:  BTFSS  FD8.1
041A:  BRA    0420
041C:  MOVLB  2
041E:  XORWF  x9C,F
0420:  MOVLB  2
0422:  CLRF   xA1
0424:  CLRF   xA2
0426:  MOVFF  298,2A0
042A:  MOVF   x9C,W
042C:  XORWF  xA0,F
042E:  MOVF   x97,W
0430:  BTFSC  FD8.2
0432:  BRA    05F2
0434:  MOVWF  x9F
0436:  MOVWF  00
0438:  MOVF   x9B,W
043A:  BTFSC  FD8.2
043C:  BRA    0604
043E:  SUBWF  x9F,F
0440:  BTFSC  FD8.2
0442:  BRA    054A
0444:  BNC   04C2
0446:  MOVFF  29C,2A5
044A:  BSF    xA5.7
044C:  MOVFF  29D,2A4
0450:  MOVFF  29E,2A3
0454:  CLRF   xA2
0456:  BCF    FD8.0
0458:  RRCF   xA5,F
045A:  RRCF   xA4,F
045C:  RRCF   xA3,F
045E:  RRCF   xA2,F
0460:  DECFSZ x9F,F
0462:  BRA    0454
0464:  BTFSS  xA0.7
0466:  BRA    046E
0468:  BSF    xA1.0
046A:  BRA    062C
046C:  BCF    xA1.0
046E:  BCF    x9F.0
0470:  BSF    xA1.4
0472:  MOVLW  02
0474:  MOVWF  FEA
0476:  MOVLW  9A
0478:  MOVWF  FE9
047A:  BRA    0652
047C:  BCF    xA1.4
047E:  BTFSC  xA0.7
0480:  BRA    0496
0482:  BTFSS  x9F.0
0484:  BRA    04AC
0486:  RRCF   xA5,F
0488:  RRCF   xA4,F
048A:  RRCF   xA3,F
048C:  RRCF   xA2,F
048E:  INCF   00,F
0490:  BTFSC  FD8.2
0492:  BRA    0622
0494:  BRA    04AC
0496:  BTFSC  xA5.7
0498:  BRA    04B2
049A:  BCF    FD8.0
049C:  RLCF   xA2,F
049E:  RLCF   xA3,F
04A0:  RLCF   xA4,F
04A2:  RLCF   xA5,F
04A4:  DECF   00,F
04A6:  BTFSC  FD8.2
04A8:  BRA    0622
04AA:  BRA    0496
04AC:  BSF    xA1.6
04AE:  BRA    058A
04B0:  BCF    xA1.6
04B2:  MOVFF  298,2A0
04B6:  BTFSS  x98.7
04B8:  BRA    04BE
04BA:  BSF    xA5.7
04BC:  BRA    0614
04BE:  BCF    xA5.7
04C0:  BRA    0614
04C2:  MOVFF  29B,29F
04C6:  MOVFF  29B,00
04CA:  MOVF   x97,W
04CC:  SUBWF  x9F,F
04CE:  MOVFF  298,2A5
04D2:  BSF    xA5.7
04D4:  MOVFF  299,2A4
04D8:  MOVFF  29A,2A3
04DC:  CLRF   xA2
04DE:  BCF    FD8.0
04E0:  RRCF   xA5,F
04E2:  RRCF   xA4,F
04E4:  RRCF   xA3,F
04E6:  RRCF   xA2,F
04E8:  DECFSZ x9F,F
04EA:  BRA    04DC
04EC:  BTFSS  xA0.7
04EE:  BRA    04F6
04F0:  BSF    xA1.1
04F2:  BRA    062C
04F4:  BCF    xA1.1
04F6:  BCF    x9F.0
04F8:  BSF    xA1.5
04FA:  MOVLW  02
04FC:  MOVWF  FEA
04FE:  MOVLW  9E
0500:  MOVWF  FE9
0502:  BRA    0652
0504:  BCF    xA1.5
0506:  BTFSC  xA0.7
0508:  BRA    051E
050A:  BTFSS  x9F.0
050C:  BRA    0534
050E:  RRCF   xA5,F
0510:  RRCF   xA4,F
0512:  RRCF   xA3,F
0514:  RRCF   xA2,F
0516:  INCF   00,F
0518:  BTFSC  FD8.2
051A:  BRA    0622
051C:  BRA    0534
051E:  BTFSC  xA5.7
0520:  BRA    053A
0522:  BCF    FD8.0
0524:  RLCF   xA2,F
0526:  RLCF   xA3,F
0528:  RLCF   xA4,F
052A:  RLCF   xA5,F
052C:  DECF   00,F
052E:  BTFSC  FD8.2
0530:  BRA    0622
0532:  BRA    051E
0534:  BSF    xA1.7
0536:  BRA    058A
0538:  BCF    xA1.7
053A:  MOVFF  29C,2A0
053E:  BTFSS  x9C.7
0540:  BRA    0546
0542:  BSF    xA5.7
0544:  BRA    0614
0546:  BCF    xA5.7
0548:  BRA    0614
054A:  MOVFF  29C,2A5
054E:  BSF    xA5.7
0550:  MOVFF  29D,2A4
0554:  MOVFF  29E,2A3
0558:  BTFSS  xA0.7
055A:  BRA    0564
055C:  BCF    xA5.7
055E:  BSF    xA1.2
0560:  BRA    062C
0562:  BCF    xA1.2
0564:  CLRF   xA2
0566:  BCF    x9F.0
0568:  MOVLW  02
056A:  MOVWF  FEA
056C:  MOVLW  9A
056E:  MOVWF  FE9
0570:  BRA    0652
0572:  BTFSC  xA0.7
0574:  BRA    05AE
0576:  MOVFF  298,2A0
057A:  BTFSS  x9F.0
057C:  BRA    058A
057E:  RRCF   xA5,F
0580:  RRCF   xA4,F
0582:  RRCF   xA3,F
0584:  RRCF   xA2,F
0586:  INCF   00,F
0588:  BZ    0622
058A:  BTFSS  xA2.7
058C:  BRA    05A4
058E:  INCF   xA3,F
0590:  BNZ   05A4
0592:  INCF   xA4,F
0594:  BNZ   05A4
0596:  INCF   xA5,F
0598:  BNZ   05A4
059A:  RRCF   xA5,F
059C:  RRCF   xA4,F
059E:  RRCF   xA3,F
05A0:  INCF   00,F
05A2:  BZ    0622
05A4:  BTFSC  xA1.6
05A6:  BRA    04B0
05A8:  BTFSC  xA1.7
05AA:  BRA    0538
05AC:  BRA    05E6
05AE:  MOVLW  80
05B0:  XORWF  xA5,F
05B2:  BTFSS  xA5.7
05B4:  BRA    05BE
05B6:  BRA    062C
05B8:  MOVFF  29C,2A0
05BC:  BRA    05D2
05BE:  MOVFF  298,2A0
05C2:  MOVF   xA5,F
05C4:  BNZ   05D2
05C6:  MOVF   xA4,F
05C8:  BNZ   05D2
05CA:  MOVF   xA3,F
05CC:  BNZ   05D2
05CE:  CLRF   00
05D0:  BRA    0614
05D2:  BTFSC  xA5.7
05D4:  BRA    05E6
05D6:  BCF    FD8.0
05D8:  RLCF   xA2,F
05DA:  RLCF   xA3,F
05DC:  RLCF   xA4,F
05DE:  RLCF   xA5,F
05E0:  DECFSZ 00,F
05E2:  BRA    05D2
05E4:  BRA    0622
05E6:  BTFSS  xA0.7
05E8:  BRA    05EE
05EA:  BSF    xA5.7
05EC:  BRA    0614
05EE:  BCF    xA5.7
05F0:  BRA    0614
05F2:  MOVFF  29B,00
05F6:  MOVFF  29C,2A5
05FA:  MOVFF  29D,2A4
05FE:  MOVFF  29E,2A3
0602:  BRA    0614
0604:  MOVFF  297,00
0608:  MOVFF  298,2A5
060C:  MOVFF  299,2A4
0610:  MOVFF  29A,2A3
0614:  MOVFF  2A5,01
0618:  MOVFF  2A4,02
061C:  MOVFF  2A3,03
0620:  BRA    068A
0622:  CLRF   00
0624:  CLRF   01
0626:  CLRF   02
0628:  CLRF   03
062A:  BRA    068A
062C:  CLRF   xA2
062E:  COMF   xA3,F
0630:  COMF   xA4,F
0632:  COMF   xA5,F
0634:  COMF   xA2,F
0636:  INCF   xA2,F
0638:  BNZ   0644
063A:  INCF   xA3,F
063C:  BNZ   0644
063E:  INCF   xA4,F
0640:  BNZ   0644
0642:  INCF   xA5,F
0644:  BTFSC  xA1.0
0646:  BRA    046C
0648:  BTFSC  xA1.1
064A:  BRA    04F4
064C:  BTFSC  xA1.2
064E:  BRA    0562
0650:  BRA    05B8
0652:  MOVF   FEF,W
0654:  ADDWF  xA3,F
0656:  BNC   0662
0658:  INCF   xA4,F
065A:  BNZ   0662
065C:  INCF   xA5,F
065E:  BTFSC  FD8.2
0660:  BSF    x9F.0
0662:  MOVF   FED,F
0664:  MOVF   FEF,W
0666:  ADDWF  xA4,F
0668:  BNC   0670
066A:  INCF   xA5,F
066C:  BTFSC  FD8.2
066E:  BSF    x9F.0
0670:  MOVF   FED,F
0672:  MOVF   FEF,W
0674:  BTFSC  FEF.7
0676:  BRA    067A
0678:  XORLW  80
067A:  ADDWF  xA5,F
067C:  BTFSC  FD8.0
067E:  BSF    x9F.0
0680:  BTFSC  xA1.4
0682:  BRA    047C
0684:  BTFSC  xA1.5
0686:  BRA    0504
0688:  BRA    0572
068A:  MOVLB  0
068C:  RETURN 0
068E:  MOVLW  8E
0690:  MOVWF  00
0692:  MOVLB  2
0694:  MOVF   x6C,W
0696:  SUBWF  00,F
0698:  MOVFF  26D,02
069C:  MOVFF  26E,01
06A0:  BSF    02.7
06A2:  MOVF   00,F
06A4:  BZ    06B8
06A6:  BCF    FD8.0
06A8:  MOVF   02,F
06AA:  BNZ   06B0
06AC:  MOVF   01,F
06AE:  BZ    06B8
06B0:  RRCF   02,F
06B2:  RRCF   01,F
06B4:  DECFSZ 00,F
06B6:  BRA    06A6
06B8:  BTFSS  x6D.7
06BA:  BRA    06C6
06BC:  COMF   01,F
06BE:  COMF   02,F
06C0:  INCF   01,F
06C2:  BTFSC  FD8.2
06C4:  INCF   02,F
06C6:  MOVLB  0
06C8:  RETURN 0
06CA:  MOVLB  2
06CC:  MOVF   x97,W
06CE:  BTFSC  FD8.2
06D0:  BRA    081C
06D2:  MOVWF  xA3
06D4:  MOVF   x9B,W
06D6:  BTFSC  FD8.2
06D8:  BRA    081C
06DA:  SUBWF  xA3,F
06DC:  BNC   06E8
06DE:  MOVLW  7F
06E0:  ADDWF  xA3,F
06E2:  BTFSC  FD8.0
06E4:  BRA    081C
06E6:  BRA    06F4
06E8:  MOVLW  81
06EA:  SUBWF  xA3,F
06EC:  BTFSS  FD8.0
06EE:  BRA    081C
06F0:  BTFSC  FD8.2
06F2:  BRA    081C
06F4:  MOVFF  2A3,00
06F8:  CLRF   01
06FA:  CLRF   02
06FC:  CLRF   03
06FE:  CLRF   xA2
0700:  MOVFF  298,2A1
0704:  BSF    xA1.7
0706:  MOVFF  299,2A0
070A:  MOVFF  29A,29F
070E:  MOVLW  19
0710:  MOVWF  xA3
0712:  MOVF   x9E,W
0714:  SUBWF  x9F,F
0716:  BC    0732
0718:  MOVLW  01
071A:  SUBWF  xA0,F
071C:  BC    0732
071E:  SUBWF  xA1,F
0720:  BC    0732
0722:  SUBWF  xA2,F
0724:  BC    0732
0726:  INCF   xA2,F
0728:  INCF   xA1,F
072A:  INCF   xA0,F
072C:  MOVF   x9E,W
072E:  ADDWF  x9F,F
0730:  BRA    0782
0732:  MOVF   x9D,W
0734:  SUBWF  xA0,F
0736:  BC    075C
0738:  MOVLW  01
073A:  SUBWF  xA1,F
073C:  BC    075C
073E:  SUBWF  xA2,F
0740:  BC    075C
0742:  INCF   xA2,F
0744:  INCF   xA1,F
0746:  MOVF   x9D,W
0748:  ADDWF  xA0,F
074A:  MOVF   x9E,W
074C:  ADDWF  x9F,F
074E:  BNC   0782
0750:  INCF   xA0,F
0752:  BNZ   0782
0754:  INCF   xA1,F
0756:  BNZ   0782
0758:  INCF   xA2,F
075A:  BRA    0782
075C:  MOVF   x9C,W
075E:  IORLW  80
0760:  SUBWF  xA1,F
0762:  BC    0780
0764:  MOVLW  01
0766:  SUBWF  xA2,F
0768:  BC    0780
076A:  INCF   xA2,F
076C:  MOVF   x9C,W
076E:  IORLW  80
0770:  ADDWF  xA1,F
0772:  MOVF   x9D,W
0774:  ADDWF  xA0,F
0776:  BNC   074A
0778:  INCF   xA1,F
077A:  BNZ   074A
077C:  INCF   xA2,F
077E:  BRA    074A
0780:  BSF    03.0
0782:  DECFSZ xA3,F
0784:  BRA    0788
0786:  BRA    079E
0788:  BCF    FD8.0
078A:  RLCF   x9F,F
078C:  RLCF   xA0,F
078E:  RLCF   xA1,F
0790:  RLCF   xA2,F
0792:  BCF    FD8.0
0794:  RLCF   03,F
0796:  RLCF   02,F
0798:  RLCF   01,F
079A:  RLCF   xA4,F
079C:  BRA    0712
079E:  BTFSS  xA4.0
07A0:  BRA    07AE
07A2:  BCF    FD8.0
07A4:  RRCF   01,F
07A6:  RRCF   02,F
07A8:  RRCF   03,F
07AA:  RRCF   xA4,F
07AC:  BRA    07B2
07AE:  DECF   00,F
07B0:  BZ    081C
07B2:  BTFSC  xA4.7
07B4:  BRA    07F2
07B6:  BCF    FD8.0
07B8:  RLCF   x9F,F
07BA:  RLCF   xA0,F
07BC:  RLCF   xA1,F
07BE:  RLCF   xA2,F
07C0:  MOVF   x9E,W
07C2:  SUBWF  x9F,F
07C4:  BC    07D4
07C6:  MOVLW  01
07C8:  SUBWF  xA0,F
07CA:  BC    07D4
07CC:  SUBWF  xA1,F
07CE:  BC    07D4
07D0:  SUBWF  xA2,F
07D2:  BNC   0808
07D4:  MOVF   x9D,W
07D6:  SUBWF  xA0,F
07D8:  BC    07E4
07DA:  MOVLW  01
07DC:  SUBWF  xA1,F
07DE:  BC    07E4
07E0:  SUBWF  xA2,F
07E2:  BNC   0808
07E4:  MOVF   x9C,W
07E6:  IORLW  80
07E8:  SUBWF  xA1,F
07EA:  BC    07F2
07EC:  MOVLW  01
07EE:  SUBWF  xA2,F
07F0:  BNC   0808
07F2:  INCF   03,F
07F4:  BNZ   0808
07F6:  INCF   02,F
07F8:  BNZ   0808
07FA:  INCF   01,F
07FC:  BNZ   0808
07FE:  INCF   00,F
0800:  BZ    081C
0802:  RRCF   01,F
0804:  RRCF   02,F
0806:  RRCF   03,F
0808:  MOVFF  298,2A3
080C:  MOVF   x9C,W
080E:  XORWF  xA3,F
0810:  BTFSS  xA3.7
0812:  BRA    0818
0814:  BSF    01.7
0816:  BRA    0824
0818:  BCF    01.7
081A:  BRA    0824
081C:  CLRF   00
081E:  CLRF   01
0820:  CLRF   02
0822:  CLRF   03
0824:  MOVLB  0
0826:  RETURN 0
*
0C8E:  MOVFF  268,26F
0C92:  MOVLB  2
0C94:  MOVF   x6C,W
0C96:  XORWF  x6F,F
0C98:  BTFSS  x6F.7
0C9A:  BRA    0CA6
0C9C:  BCF    FD8.2
0C9E:  BCF    FD8.0
0CA0:  BTFSC  x68.7
0CA2:  BSF    FD8.0
0CA4:  BRA    0D04
0CA6:  MOVFF  268,26F
0CAA:  MOVFF  26B,270
0CAE:  MOVF   x67,W
0CB0:  SUBWF  x70,F
0CB2:  BZ    0CC0
0CB4:  BTFSS  x6F.7
0CB6:  BRA    0D04
0CB8:  MOVF   FD8,W
0CBA:  XORLW  01
0CBC:  MOVWF  FD8
0CBE:  BRA    0D04
0CC0:  MOVFF  26C,270
0CC4:  MOVF   x68,W
0CC6:  SUBWF  x70,F
0CC8:  BZ    0CD6
0CCA:  BTFSS  x6F.7
0CCC:  BRA    0D04
0CCE:  MOVF   FD8,W
0CD0:  XORLW  01
0CD2:  MOVWF  FD8
0CD4:  BRA    0D04
0CD6:  MOVFF  26D,270
0CDA:  MOVF   x69,W
0CDC:  SUBWF  x70,F
0CDE:  BZ    0CEC
0CE0:  BTFSS  x6F.7
0CE2:  BRA    0D04
0CE4:  MOVF   FD8,W
0CE6:  XORLW  01
0CE8:  MOVWF  FD8
0CEA:  BRA    0D04
0CEC:  MOVFF  26E,270
0CF0:  MOVF   x6A,W
0CF2:  SUBWF  x70,F
0CF4:  BZ    0D02
0CF6:  BTFSS  x6F.7
0CF8:  BRA    0D04
0CFA:  MOVF   FD8,W
0CFC:  XORLW  01
0CFE:  MOVWF  FD8
0D00:  BRA    0D04
0D02:  BCF    FD8.0
0D04:  MOVLB  0
0D06:  RETURN 0
0D08:  MOVLB  2
0D0A:  MOVF   x95,W
0D0C:  SUBLW  B6
0D0E:  MOVWF  x95
0D10:  CLRF   03
0D12:  MOVFF  296,299
0D16:  BSF    x96.7
0D18:  BCF    FD8.0
0D1A:  RRCF   x96,F
0D1C:  RRCF   x97,F
0D1E:  RRCF   x98,F
0D20:  RRCF   03,F
0D22:  RRCF   02,F
0D24:  RRCF   01,F
0D26:  RRCF   00,F
0D28:  DECFSZ x95,F
0D2A:  BRA    0D18
0D2C:  BTFSS  x99.7
0D2E:  BRA    0D46
0D30:  COMF   00,F
0D32:  COMF   01,F
0D34:  COMF   02,F
0D36:  COMF   03,F
0D38:  INCF   00,F
0D3A:  BTFSC  FD8.2
0D3C:  INCF   01,F
0D3E:  BTFSC  FD8.2
0D40:  INCF   02,F
0D42:  BTFSC  FD8.2
0D44:  INCF   03,F
0D46:  MOVLB  0
0D48:  RETURN 0
0D4A:  BTFSC  FD8.1
0D4C:  BRA    0D56
0D4E:  MOVLW  02
0D50:  MOVWF  FEA
0D52:  MOVLW  9D
0D54:  MOVWF  FE9
0D56:  CLRF   00
0D58:  CLRF   01
0D5A:  CLRF   02
0D5C:  CLRF   03
0D5E:  MOVLB  2
0D60:  CLRF   x9D
0D62:  CLRF   x9E
0D64:  CLRF   x9F
0D66:  CLRF   xA0
0D68:  MOVF   x9C,W
0D6A:  IORWF  x9B,W
0D6C:  IORWF  x9A,W
0D6E:  IORWF  x99,W
0D70:  BZ    0DCA
0D72:  MOVLW  20
0D74:  MOVWF  xA1
0D76:  BCF    FD8.0
0D78:  RLCF   x95,F
0D7A:  RLCF   x96,F
0D7C:  RLCF   x97,F
0D7E:  RLCF   x98,F
0D80:  RLCF   x9D,F
0D82:  RLCF   x9E,F
0D84:  RLCF   x9F,F
0D86:  RLCF   xA0,F
0D88:  MOVF   x9C,W
0D8A:  SUBWF  xA0,W
0D8C:  BNZ   0D9E
0D8E:  MOVF   x9B,W
0D90:  SUBWF  x9F,W
0D92:  BNZ   0D9E
0D94:  MOVF   x9A,W
0D96:  SUBWF  x9E,W
0D98:  BNZ   0D9E
0D9A:  MOVF   x99,W
0D9C:  SUBWF  x9D,W
0D9E:  BNC   0DBE
0DA0:  MOVF   x99,W
0DA2:  SUBWF  x9D,F
0DA4:  MOVF   x9A,W
0DA6:  BTFSS  FD8.0
0DA8:  INCFSZ x9A,W
0DAA:  SUBWF  x9E,F
0DAC:  MOVF   x9B,W
0DAE:  BTFSS  FD8.0
0DB0:  INCFSZ x9B,W
0DB2:  SUBWF  x9F,F
0DB4:  MOVF   x9C,W
0DB6:  BTFSS  FD8.0
0DB8:  INCFSZ x9C,W
0DBA:  SUBWF  xA0,F
0DBC:  BSF    FD8.0
0DBE:  RLCF   00,F
0DC0:  RLCF   01,F
0DC2:  RLCF   02,F
0DC4:  RLCF   03,F
0DC6:  DECFSZ xA1,F
0DC8:  BRA    0D76
0DCA:  MOVFF  29D,FEF
0DCE:  MOVFF  29E,FEC
0DD2:  MOVFF  29F,FEC
0DD6:  MOVFF  2A0,FEC
0DDA:  MOVLB  0
0DDC:  RETURN 0
0DDE:  MOVFF  263,FEA
0DE2:  MOVFF  262,FE9
0DE6:  MOVLB  2
0DE8:  MOVFF  274,FEF
0DEC:  INCF   FE9,F
0DEE:  BTFSC  FD8.2
0DF0:  INCF   FEA,F
0DF2:  CLRF   FEF
0DF4:  INCF   x62,F
0DF6:  BTFSC  FD8.2
0DF8:  INCF   x63,F
0DFA:  MOVLB  0
0DFC:  RETURN 0
0DFE:  MOVF   FE9,W
0E00:  MOVLB  2
0E02:  MOVWF  x6C
0E04:  MOVF   x6B,W
0E06:  MOVWF  x6E
0E08:  BZ    0E42
0E0A:  MOVFF  26A,298
0E0E:  MOVFF  269,297
0E12:  MOVFF  268,296
0E16:  MOVFF  267,295
0E1A:  CLRF   x9C
0E1C:  CLRF   x9B
0E1E:  MOVLW  20
0E20:  MOVWF  x9A
0E22:  MOVLW  82
0E24:  MOVWF  x99
0E26:  MOVLB  0
0E28:  CALL   0320
0E2C:  MOVFF  03,26A
0E30:  MOVFF  02,269
0E34:  MOVFF  01,268
0E38:  MOVFF  00,267
0E3C:  MOVLB  2
0E3E:  DECFSZ x6E,F
0E40:  BRA    0E0A
0E42:  MOVFF  26A,298
0E46:  MOVFF  269,297
0E4A:  MOVFF  268,296
0E4E:  MOVFF  267,295
0E52:  MOVLB  0
0E54:  RCALL  0D08
0E56:  MOVFF  03,26A
0E5A:  MOVFF  02,269
0E5E:  MOVFF  01,268
0E62:  MOVFF  00,267
0E66:  MOVLB  2
0E68:  BTFSS  x6A.7
0E6A:  BRA    0E86
0E6C:  DECF   x6C,F
0E6E:  BSF    x6C.5
0E70:  COMF   x67,F
0E72:  COMF   x68,F
0E74:  COMF   x69,F
0E76:  COMF   x6A,F
0E78:  INCF   x67,F
0E7A:  BTFSC  FD8.2
0E7C:  INCF   x68,F
0E7E:  BTFSC  FD8.2
0E80:  INCF   x69,F
0E82:  BTFSC  FD8.2
0E84:  INCF   x6A,F
0E86:  MOVLW  3B
0E88:  MOVWF  x73
0E8A:  MOVLW  9A
0E8C:  MOVWF  x72
0E8E:  MOVLW  CA
0E90:  MOVWF  x71
0E92:  CLRF   x70
0E94:  MOVLW  0A
0E96:  MOVWF  x6E
0E98:  MOVF   x6B,W
0E9A:  BTFSC  FD8.2
0E9C:  INCF   x6C,F
0E9E:  BSF    FD8.1
0EA0:  MOVLW  02
0EA2:  MOVWF  FEA
0EA4:  MOVLW  67
0EA6:  MOVWF  FE9
0EA8:  MOVFF  26A,298
0EAC:  MOVFF  269,297
0EB0:  MOVFF  268,296
0EB4:  MOVFF  267,295
0EB8:  MOVFF  273,29C
0EBC:  MOVFF  272,29B
0EC0:  MOVFF  271,29A
0EC4:  MOVFF  270,299
0EC8:  MOVLB  0
0ECA:  RCALL  0D4A
0ECC:  MOVF   01,W
0ECE:  MOVF   00,F
0ED0:  BNZ   0EF8
0ED2:  MOVLB  2
0ED4:  INCF   x6B,W
0ED6:  SUBWF  x6E,W
0ED8:  BTFSS  FD8.2
0EDA:  BRA    0EE0
0EDC:  MOVLB  0
0EDE:  BRA    0EF8
0EE0:  MOVF   x6C,W
0EE2:  BZ    0EFE
0EE4:  ANDLW  0F
0EE6:  SUBWF  x6E,W
0EE8:  BZ    0EEC
0EEA:  BC    0F6C
0EEC:  BTFSC  x6C.7
0EEE:  BRA    0F6C
0EF0:  BTFSC  x6C.6
0EF2:  BRA    0EFE
0EF4:  MOVLW  20
0EF6:  BRA    0F60
0EF8:  MOVLW  20
0EFA:  MOVLB  2
0EFC:  ANDWF  x6C,F
0EFE:  BTFSS  x6C.5
0F00:  BRA    0F1E
0F02:  BCF    x6C.5
0F04:  MOVF   x6B,W
0F06:  BTFSS  FD8.2
0F08:  DECF   x6C,F
0F0A:  MOVF   00,W
0F0C:  MOVWF  x6C
0F0E:  MOVLW  2D
0F10:  MOVWF  x74
0F12:  MOVLB  0
0F14:  RCALL  0DDE
0F16:  MOVLB  2
0F18:  MOVF   x6C,W
0F1A:  MOVWF  00
0F1C:  CLRF   x6C
0F1E:  MOVF   x6B,W
0F20:  SUBWF  x6E,W
0F22:  BNZ   0F3C
0F24:  MOVF   00,W
0F26:  MOVWF  x6C
0F28:  MOVLW  2E
0F2A:  MOVWF  x74
0F2C:  MOVLB  0
0F2E:  RCALL  0DDE
0F30:  MOVLB  2
0F32:  MOVF   x6C,W
0F34:  MOVWF  00
0F36:  MOVLW  20
0F38:  ANDWF  x6C,F
0F3A:  MOVLW  00
0F3C:  MOVLW  30
0F3E:  BTFSS  x6C.5
0F40:  BRA    0F60
0F42:  BCF    x6C.5
0F44:  MOVF   x6B,W
0F46:  BTFSS  FD8.2
0F48:  DECF   x6C,F
0F4A:  MOVF   00,W
0F4C:  MOVWF  x6C
0F4E:  MOVLW  2D
0F50:  MOVWF  x74
0F52:  MOVLB  0
0F54:  RCALL  0DDE
0F56:  MOVLB  2
0F58:  MOVF   x6C,W
0F5A:  MOVWF  00
0F5C:  CLRF   x6C
0F5E:  MOVLW  30
0F60:  ADDWF  00,F
0F62:  MOVFF  00,274
0F66:  MOVLB  0
0F68:  RCALL  0DDE
0F6A:  MOVLB  2
0F6C:  BCF    FD8.1
0F6E:  MOVFF  273,298
0F72:  MOVFF  272,297
0F76:  MOVFF  271,296
0F7A:  MOVFF  270,295
0F7E:  CLRF   x9C
0F80:  CLRF   x9B
0F82:  CLRF   x9A
0F84:  MOVLW  0A
0F86:  MOVWF  x99
0F88:  MOVLB  0
0F8A:  RCALL  0D4A
0F8C:  MOVFF  03,273
0F90:  MOVFF  02,272
0F94:  MOVFF  01,271
0F98:  MOVFF  00,270
0F9C:  MOVLB  2
0F9E:  DECFSZ x6E,F
0FA0:  BRA    0E9E
0FA2:  MOVLB  0
0FA4:  RETURN 0
*
149C:  TBLRD*+
149E:  MOVF   FF5,F
14A0:  BZ    14BC
14A2:  MOVFF  FF6,280
14A6:  MOVFF  FF7,281
14AA:  MOVF   FF5,W
14AC:  BTFSS  F9E.4
14AE:  BRA    14AC
14B0:  MOVWF  FAD
14B2:  MOVFF  280,FF6
14B6:  MOVFF  281,FF7
14BA:  BRA    149C
14BC:  GOTO   17BC (RETURN)
14C0:  TBLRD*+
14C2:  MOVFF  FF6,289
14C6:  MOVFF  FF7,28A
14CA:  MOVF   FF5,W
14CC:  BTFSS  F9E.4
14CE:  BRA    14CC
14D0:  MOVWF  FAD
14D2:  MOVFF  289,FF6
14D6:  MOVFF  28A,FF7
14DA:  MOVLB  2
14DC:  DECFSZ x88,F
14DE:  BRA    14E2
14E0:  BRA    14E6
14E2:  MOVLB  0
14E4:  BRA    14C0
14E6:  MOVLB  0
14E8:  RETURN 0
14EA:  MOVF   FE9,W
14EC:  MOVLB  2
14EE:  MOVWF  x8D
14F0:  MOVF   x8C,W
14F2:  MOVWF  x8F
14F4:  BZ    152E
14F6:  MOVFF  28B,298
14FA:  MOVFF  28A,297
14FE:  MOVFF  289,296
1502:  MOVFF  288,295
1506:  CLRF   x9C
1508:  CLRF   x9B
150A:  MOVLW  20
150C:  MOVWF  x9A
150E:  MOVLW  82
1510:  MOVWF  x99
1512:  MOVLB  0
1514:  CALL   0320
1518:  MOVFF  03,28B
151C:  MOVFF  02,28A
1520:  MOVFF  01,289
1524:  MOVFF  00,288
1528:  MOVLB  2
152A:  DECFSZ x8F,F
152C:  BRA    14F6
152E:  MOVFF  28B,298
1532:  MOVFF  28A,297
1536:  MOVFF  289,296
153A:  MOVFF  288,295
153E:  MOVLB  0
1540:  CALL   0D08
1544:  MOVFF  03,28B
1548:  MOVFF  02,28A
154C:  MOVFF  01,289
1550:  MOVFF  00,288
1554:  MOVLB  2
1556:  BTFSS  x8B.7
1558:  BRA    1574
155A:  DECF   x8D,F
155C:  BSF    x8D.5
155E:  COMF   x88,F
1560:  COMF   x89,F
1562:  COMF   x8A,F
1564:  COMF   x8B,F
1566:  INCF   x88,F
1568:  BTFSC  FD8.2
156A:  INCF   x89,F
156C:  BTFSC  FD8.2
156E:  INCF   x8A,F
1570:  BTFSC  FD8.2
1572:  INCF   x8B,F
1574:  MOVLW  3B
1576:  MOVWF  x94
1578:  MOVLW  9A
157A:  MOVWF  x93
157C:  MOVLW  CA
157E:  MOVWF  x92
1580:  CLRF   x91
1582:  MOVLW  0A
1584:  MOVWF  x8F
1586:  MOVF   x8C,W
1588:  BTFSC  FD8.2
158A:  INCF   x8D,F
158C:  BSF    FD8.1
158E:  MOVLW  02
1590:  MOVWF  FEA
1592:  MOVLW  88
1594:  MOVWF  FE9
1596:  MOVFF  28B,298
159A:  MOVFF  28A,297
159E:  MOVFF  289,296
15A2:  MOVFF  288,295
15A6:  MOVFF  294,29C
15AA:  MOVFF  293,29B
15AE:  MOVFF  292,29A
15B2:  MOVFF  291,299
15B6:  MOVLB  0
15B8:  CALL   0D4A
15BC:  MOVF   01,W
15BE:  MOVF   00,F
15C0:  BNZ   15E8
15C2:  MOVLB  2
15C4:  INCF   x8C,W
15C6:  SUBWF  x8F,W
15C8:  BTFSS  FD8.2
15CA:  BRA    15D0
15CC:  MOVLB  0
15CE:  BRA    15E8
15D0:  MOVF   x8D,W
15D2:  BZ    15EE
15D4:  ANDLW  0F
15D6:  SUBWF  x8F,W
15D8:  BZ    15DC
15DA:  BC    1654
15DC:  BTFSC  x8D.7
15DE:  BRA    1654
15E0:  BTFSC  x8D.6
15E2:  BRA    15EE
15E4:  MOVLW  20
15E6:  BRA    164A
15E8:  MOVLW  20
15EA:  MOVLB  2
15EC:  ANDWF  x8D,F
15EE:  BTFSS  x8D.5
15F0:  BRA    160C
15F2:  BCF    x8D.5
15F4:  MOVF   x8C,W
15F6:  BTFSS  FD8.2
15F8:  DECF   x8D,F
15FA:  MOVF   00,W
15FC:  MOVWF  x8D
15FE:  MOVLW  2D
1600:  BTFSS  F9E.4
1602:  BRA    1600
1604:  MOVWF  FAD
1606:  MOVF   x8D,W
1608:  MOVWF  00
160A:  CLRF   x8D
160C:  MOVF   x8C,W
160E:  SUBWF  x8F,W
1610:  BNZ   1628
1612:  MOVF   00,W
1614:  MOVWF  x8D
1616:  MOVLW  2E
1618:  BTFSS  F9E.4
161A:  BRA    1618
161C:  MOVWF  FAD
161E:  MOVF   x8D,W
1620:  MOVWF  00
1622:  MOVLW  20
1624:  ANDWF  x8D,F
1626:  MOVLW  00
1628:  MOVLW  30
162A:  BTFSS  x8D.5
162C:  BRA    164A
162E:  BCF    x8D.5
1630:  MOVF   x8C,W
1632:  BTFSS  FD8.2
1634:  DECF   x8D,F
1636:  MOVF   00,W
1638:  MOVWF  x8D
163A:  MOVLW  2D
163C:  BTFSS  F9E.4
163E:  BRA    163C
1640:  MOVWF  FAD
1642:  MOVF   x8D,W
1644:  MOVWF  00
1646:  CLRF   x8D
1648:  MOVLW  30
164A:  ADDWF  00,F
164C:  MOVF   00,W
164E:  BTFSS  F9E.4
1650:  BRA    164E
1652:  MOVWF  FAD
1654:  BCF    FD8.1
1656:  MOVFF  294,298
165A:  MOVFF  293,297
165E:  MOVFF  292,296
1662:  MOVFF  291,295
1666:  CLRF   x9C
1668:  CLRF   x9B
166A:  CLRF   x9A
166C:  MOVLW  0A
166E:  MOVWF  x99
1670:  MOVLB  0
1672:  CALL   0D4A
1676:  MOVFF  03,294
167A:  MOVFF  02,293
167E:  MOVFF  01,292
1682:  MOVFF  00,291
1686:  MOVLB  2
1688:  DECFSZ x8F,F
168A:  BRA    158C
168C:  MOVLB  0
168E:  RETURN 0
....................  
.................... #list 
....................  
.................... #fuses NOPROTECT, NOWDT 
.................... #device adc = 10 
.................... #use delay(clock=8000000) 
*
021A:  MOVLW  02
021C:  MOVWF  FEA
021E:  MOVLW  81
0220:  MOVWF  FE9
0222:  MOVF   FEF,W
0224:  BZ    0240
0226:  MOVLW  02
0228:  MOVWF  01
022A:  CLRF   00
022C:  DECFSZ 00,F
022E:  BRA    022C
0230:  DECFSZ 01,F
0232:  BRA    022A
0234:  MOVLW  97
0236:  MOVWF  00
0238:  DECFSZ 00,F
023A:  BRA    0238
023C:  DECFSZ FEF,F
023E:  BRA    0226
0240:  RETURN 0
.................... #use RS232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_C6, RCV=PIN_C7) 
....................  
.................... #include "Definitions.h" 
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
*
0962:  MOVLB  2
0964:  CLRF   x8B
0966:  CLRF   x8A
0968:  CLRF   x89
096A:  MOVLW  7F
096C:  MOVWF  x88
096E:  CLRF   x8F
0970:  CLRF   x8E
0972:  CLRF   x8D
0974:  CLRF   x8C
0976:  BSF    x90.0
0978:  BCF    x90.1
097A:  BCF    x90.2
097C:  CLRF   x92
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
097E:  MOVF   x84,W
0980:  IORWF  x85,W
0982:  BNZ   098E
....................       return 0; 
0984:  CLRF   00
0986:  CLRF   01
0988:  CLRF   02
098A:  CLRF   03
098C:  BRA    0BAA
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
098E:  MOVF   x92,W
0990:  INCF   x92,F
0992:  ADDWF  x84,W
0994:  MOVWF  FE9
0996:  MOVLW  00
0998:  ADDWFC x85,W
099A:  MOVWF  FEA
099C:  MOVFF  FEF,291
09A0:  MOVF   x91,F
09A2:  BTFSC  FD8.2
09A4:  BRA    0B2E
....................    { 
....................       if (skip && !isspace(c)) 
09A6:  BTFSS  x90.0
09A8:  BRA    09C8
09AA:  MOVF   x91,W
09AC:  SUBLW  20
09AE:  BZ    09C8
....................       { 
....................          skip = 0; 
09B0:  BCF    x90.0
....................          if (c == '+') 
09B2:  MOVF   x91,W
09B4:  SUBLW  2B
09B6:  BNZ   09BE
....................          { 
....................             sign = 0; 
09B8:  BCF    x90.1
....................             continue; 
09BA:  BRA    0B16
....................          }             
09BC:  BRA    09C8
....................          else if (c == '-') 
09BE:  MOVF   x91,W
09C0:  SUBLW  2D
09C2:  BNZ   09C8
....................          { 
....................             sign = 1; 
09C4:  BSF    x90.1
....................             continue; 
09C6:  BRA    0B16
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
09C8:  BTFSC  x90.0
09CA:  BRA    09DA
09CC:  MOVF   x91,W
09CE:  SUBLW  2E
09D0:  BNZ   09DA
09D2:  BTFSC  x90.2
09D4:  BRA    09DA
....................          point = 1; 
09D6:  BSF    x90.2
09D8:  BRA    0B16
....................       else if (!skip && isdigit(c)) 
09DA:  BTFSC  x90.0
09DC:  BRA    0B10
09DE:  MOVF   x91,W
09E0:  SUBLW  2F
09E2:  BTFSC  FD8.0
09E4:  BRA    0B10
09E6:  MOVF   x91,W
09E8:  SUBLW  39
09EA:  BTFSS  FD8.0
09EC:  BRA    0B10
....................       { 
....................          c -= '0'; 
09EE:  MOVLW  30
09F0:  SUBWF  x91,F
....................          if (point) 
09F2:  BTFSS  x90.2
09F4:  BRA    0A9C
....................          { 
....................             pow10 = pow10 * 10.0; 
09F6:  MOVFF  28B,298
09FA:  MOVFF  28A,297
09FE:  MOVFF  289,296
0A02:  MOVFF  288,295
0A06:  CLRF   x9C
0A08:  CLRF   x9B
0A0A:  MOVLW  20
0A0C:  MOVWF  x9A
0A0E:  MOVLW  82
0A10:  MOVWF  x99
0A12:  MOVLB  0
0A14:  RCALL  0320
0A16:  MOVFF  03,28B
0A1A:  MOVFF  02,28A
0A1E:  MOVFF  01,289
0A22:  MOVFF  00,288
....................             result += (float)c / pow10;    
0A26:  MOVLB  2
0A28:  CLRF   x98
0A2A:  MOVFF  291,297
0A2E:  MOVLB  0
0A30:  RCALL  02EA
0A32:  MOVFF  03,296
0A36:  MOVFF  02,295
0A3A:  MOVFF  01,294
0A3E:  MOVFF  00,293
0A42:  MOVFF  03,29A
0A46:  MOVFF  02,299
0A4A:  MOVFF  01,298
0A4E:  MOVFF  00,297
0A52:  MOVFF  28B,29E
0A56:  MOVFF  28A,29D
0A5A:  MOVFF  289,29C
0A5E:  MOVFF  288,29B
0A62:  RCALL  06CA
0A64:  BCF    FD8.1
0A66:  MOVFF  28F,29A
0A6A:  MOVFF  28E,299
0A6E:  MOVFF  28D,298
0A72:  MOVFF  28C,297
0A76:  MOVFF  03,29E
0A7A:  MOVFF  02,29D
0A7E:  MOVFF  01,29C
0A82:  MOVFF  00,29B
0A86:  RCALL  0416
0A88:  MOVFF  03,28F
0A8C:  MOVFF  02,28E
0A90:  MOVFF  01,28D
0A94:  MOVFF  00,28C
....................          } 
0A98:  BRA    0B0C
0A9A:  MOVLB  2
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
0A9C:  CLRF   x98
0A9E:  CLRF   x97
0AA0:  MOVLW  20
0AA2:  MOVWF  x96
0AA4:  MOVLW  82
0AA6:  MOVWF  x95
0AA8:  MOVFF  28F,29C
0AAC:  MOVFF  28E,29B
0AB0:  MOVFF  28D,29A
0AB4:  MOVFF  28C,299
0AB8:  MOVLB  0
0ABA:  RCALL  0320
0ABC:  MOVFF  03,296
0AC0:  MOVFF  02,295
0AC4:  MOVFF  01,294
0AC8:  MOVFF  00,293
0ACC:  MOVLB  2
0ACE:  CLRF   x98
0AD0:  MOVFF  291,297
0AD4:  MOVLB  0
0AD6:  RCALL  02EA
0AD8:  BCF    FD8.1
0ADA:  MOVFF  296,29A
0ADE:  MOVFF  295,299
0AE2:  MOVFF  294,298
0AE6:  MOVFF  293,297
0AEA:  MOVFF  03,29E
0AEE:  MOVFF  02,29D
0AF2:  MOVFF  01,29C
0AF6:  MOVFF  00,29B
0AFA:  RCALL  0416
0AFC:  MOVFF  03,28F
0B00:  MOVFF  02,28E
0B04:  MOVFF  01,28D
0B08:  MOVFF  00,28C
....................          } 
....................       } 
0B0C:  BRA    0B18
0B0E:  MOVLB  2
....................       else if (!skip) 
0B10:  BTFSC  x90.0
0B12:  BRA    0B16
....................          break; 
0B14:  BRA    0B2E
0B16:  MOVLB  0
0B18:  MOVLB  2
0B1A:  MOVF   x92,W
0B1C:  INCF   x92,F
0B1E:  ADDWF  x84,W
0B20:  MOVWF  FE9
0B22:  MOVLW  00
0B24:  ADDWFC x85,W
0B26:  MOVWF  FEA
0B28:  MOVFF  FEF,291
0B2C:  BRA    09A0
....................    } 
....................  
....................    if (sign) 
0B2E:  BTFSS  x90.1
0B30:  BRA    0B66
....................       result = -1*result; 
0B32:  CLRF   x98
0B34:  CLRF   x97
0B36:  MOVLW  80
0B38:  MOVWF  x96
0B3A:  MOVLW  7F
0B3C:  MOVWF  x95
0B3E:  MOVFF  28F,29C
0B42:  MOVFF  28E,29B
0B46:  MOVFF  28D,29A
0B4A:  MOVFF  28C,299
0B4E:  MOVLB  0
0B50:  CALL   0320
0B54:  MOVFF  03,28F
0B58:  MOVFF  02,28E
0B5C:  MOVFF  01,28D
0B60:  MOVFF  00,28C
0B64:  MOVLB  2
....................        
....................    if(endptr) 
0B66:  MOVF   x86,W
0B68:  IORWF  x87,W
0B6A:  BZ    0B9A
....................    { 
....................       if (ptr) { 
0B6C:  MOVF   x92,F
0B6E:  BZ    0B88
....................          ptr--; 
0B70:  DECF   x92,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
0B72:  MOVFF  286,FE9
0B76:  MOVFF  287,FEA
0B7A:  MOVF   x92,W
0B7C:  ADDWF  x84,W
0B7E:  MOVWF  FEF
0B80:  MOVLW  00
0B82:  ADDWFC x85,W
0B84:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
0B86:  BRA    0B9A
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
0B88:  MOVFF  286,FE9
0B8C:  MOVFF  287,FEA
0B90:  MOVFF  285,FEC
0B94:  MOVF   FED,F
0B96:  MOVFF  284,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
0B9A:  MOVFF  28C,00
0B9E:  MOVFF  28D,01
0BA2:  MOVFF  28E,02
0BA6:  MOVFF  28F,03
0BAA:  MOVLB  0
0BAC:  RETURN 0
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
....................  
.................... #define ONE_SEC 33  // 1000/((4/8000)*(65535)(1)) = 32.767 
.................... #define TEN_SEC ONE_SEC*10  
.................... #define buf_length 255 
.................... #define TELEPHONE_LENGHT 10 
.................... #define TELEPHONE_ADDRESS 25 
.................... #define DISTANCE_LIMIT 512 
.................... // Send message stuff 
.................... #define Send_Message input(PIN_b0) 
....................  
.................... volatile unsigned int8 timerCounter = 0; 
.................... volatile unsigned int16 timerGPS    = 0; 
....................  
.................... // GPS Variables 
.................... char LatRead[10], LonRead[10]; 
.................... int savePosition =  0; 
.................... int GPS_Connected = 0; 
.................... float latitud = 0, longitud = 0; 
.................... char LatWrite[10]; 
.................... char LonWrite[10]; 
.................... float latitudConverted  = 0; 
.................... float longitudConverted = 0; 
....................  
.................... // Power Moduled variables 
.................... //int duty = 0; 
....................  
.................... // Phone message variables 
.................... //char _Cel1[8], _Cel2[8]; 
.................... //float Num1, Num2; 
....................  
.................... // Buffer variables  
.................... volatile char str[buf_length], buf[buf_length]; 
.................... int str_flag = 0, flag_buf = 0, str_flag2=0; 
.................... int i = 0; 
....................  
.................... // ADC Variables 
.................... //int16 data_adc0 = 0, mmDistance = 0, distancePower = 0;  
.................... float voltage = 0; 
....................  
....................  
.................... void setup(); 
.................... void start_alert(); 
.................... void Motor1_Start(); 
.................... void If_Message(void); 
.................... void process_tel_number(); 
.................... void Get_GPS(); 
.................... void gps_info_processor(void); 
.................... void dummyFunction(char characterRecived); 
.................... int16 AdcReadAndProcessing(); 
....................  
.................... #INT_TIMER0 
.................... void t0() 
.................... { 
....................    timerCounter++; 
*
00BA:  INCF   1F,F
....................    if(timerCounter == ONE_SEC) 
00BC:  MOVF   1F,W
00BE:  SUBLW  21
00C0:  BNZ   00C8
....................    { 
....................       output_toggle(pin_a5); 
00C2:  BCF    F92.5
00C4:  BTG    F89.5
....................       timerCounter = 0; 
00C6:  CLRF   1F
....................    } 
....................    timerGPS++; 
00C8:  INCF   20,F
00CA:  BTFSC  FD8.2
00CC:  INCF   21,F
....................    if(timerGPS == TEN_SEC) 
00CE:  MOVF   20,W
00D0:  SUBLW  4A
00D2:  BNZ   00E0
00D4:  DECFSZ 21,W
00D6:  BRA    00E0
....................    { 
....................       savePosition = 1; 
00D8:  MOVLW  01
00DA:  MOVWF  36
....................       timerGPS = 0; 
00DC:  CLRF   21
00DE:  CLRF   20
....................    } 
.................... } 
....................  
00E0:  BCF    FF2.2
00E2:  GOTO   006C
.................... #INT_rda 
.................... void rda_isr() 
*
0184:  BTFSS  F9E.5
0186:  BRA    0184
0188:  MOVFF  FAE,2A7
018C:  MOVLB  2
.................... { 
....................    volatile char characterRecived = getchar (); 
....................    dummyFunction(characterRecived); 
018E:  MOVFF  2A7,2A8
0192:  MOVLB  0
0194:  BRA    00E6
0196:  BCF    F9E.5
0198:  GOTO   006C
.................... } 
....................  
.................... void main() 
*
19B6:  CLRF   FF8
19B8:  BCF    FD0.7
19BA:  BSF    07.7
19BC:  BCF    FB8.3
19BE:  MOVLW  0C
19C0:  MOVWF  FAF
19C2:  MOVLW  A2
19C4:  MOVWF  FAC
19C6:  MOVLW  90
19C8:  MOVWF  FAB
19CA:  CLRF   1F
19CC:  CLRF   21
19CE:  CLRF   20
19D0:  CLRF   36
19D2:  CLRF   37
19D4:  CLRF   3B
19D6:  CLRF   3A
19D8:  CLRF   39
19DA:  CLRF   38
19DC:  CLRF   3F
19DE:  CLRF   3E
19E0:  CLRF   3D
19E2:  CLRF   3C
19E4:  CLRF   57
19E6:  CLRF   56
19E8:  CLRF   55
19EA:  CLRF   54
19EC:  CLRF   5B
19EE:  CLRF   5A
19F0:  CLRF   59
19F2:  CLRF   58
19F4:  MOVLB  2
19F6:  CLRF   x5A
19F8:  CLRF   x5B
19FA:  CLRF   x5C
19FC:  CLRF   x5D
19FE:  CLRF   x61
1A00:  CLRF   x60
1A02:  CLRF   x5F
1A04:  CLRF   x5E
1A06:  CLRF   x63
1A08:  CLRF   x62
1A0A:  MOVF   FC1,W
1A0C:  ANDLW  C0
1A0E:  IORLW  0F
1A10:  MOVWF  FC1
1A12:  MOVLW  07
1A14:  MOVWF  FB4
1A16:  CLRF   19
1A18:  CLRF   1A
.................... { 
....................    int16 distancePower; 
....................    setup(); 
1A1A:  MOVLB  0
1A1C:  GOTO   01E8
....................    start_alert(); 
1A20:  GOTO   0242
....................    Motor1_Start(); // Starts motor and confgures timer2 
1A24:  GOTO   0290
....................     
....................    set_adc_channel(0); 
1A28:  MOVLW  00
1A2A:  MOVWF  01
1A2C:  MOVF   FC2,W
1A2E:  ANDLW  C3
1A30:  IORWF  01,W
1A32:  MOVWF  FC2
....................     
....................    while(TRUE) 
....................    {     
....................       distancePower = AdcReadAndProcessing(); 
1A34:  GOTO   0828
1A38:  MOVFF  02,265
1A3C:  MOVFF  01,264
....................       set_pwm1_duty(distancePower); 
1A40:  MOVFF  265,02
1A44:  MOVFF  264,01
1A48:  RRCF   02,F
1A4A:  RRCF   01,F
1A4C:  RRCF   02,F
1A4E:  RRCF   01,F
1A50:  RRCF   02,F
1A52:  MOVFF  01,FBE
1A56:  RRCF   02,F
1A58:  RRCF   02,W
1A5A:  ANDLW  30
1A5C:  MOVWF  00
1A5E:  MOVF   FBD,W
1A60:  ANDLW  CF
1A62:  IORWF  00,W
1A64:  MOVWF  FBD
....................       Get_GPS(); 
1A66:  GOTO   0BAE
....................       gps_info_processor(); 
1A6A:  GOTO   0FA6
....................       If_Message(); 
1A6E:  BRA    1690
....................       process_tel_number();  
1A70:  BRA    1902
1A72:  BRA    1A34
....................    } 
.................... } 
....................  
1A74:  SLEEP 
.................... void setup() 
.................... { 
....................    setup_oscillator( OSC_8MHZ | OSC_INTRC );  
*
01E8:  MOVLW  72
01EA:  MOVWF  FD3
01EC:  MOVF   FD3,W
....................    setup_adc (ADC_CLOCK_INTERNAL); 
01EE:  BSF    FC0.0
01F0:  BSF    FC0.1
01F2:  BSF    FC0.2
01F4:  BSF    FC0.7
01F6:  BSF    FC2.0
....................    setup_adc_ports (AN0 | VSS_VDD); //Read ADC0 
01F8:  MOVF   FC1,W
01FA:  ANDLW  C0
01FC:  IORLW  0E
01FE:  MOVWF  FC1
....................    enable_interrupts(INT_TIMER0); 
0200:  BSF    FF2.5
....................    enable_interrupts(INT_RDA);        
0202:  BSF    F9D.5
....................    enable_interrupts(GLOBAL); 
0204:  MOVLW  C0
0206:  IORWF  FF2,F
....................    set_timer0(65535); 
0208:  SETF   FD7
020A:  SETF   FD6
....................    setup_counters(T0_DIV_1, 1); 
020C:  BCF    FD1.0
020E:  MOVLW  89
0210:  MOVWF  FD5
....................    setup_timer_0(T0_DIV_1); 
0212:  MOVLW  88
0214:  MOVWF  FD5
0216:  GOTO   1A20 (RETURN)
.................... } 
....................  
.................... void start_alert() 
.................... { 
....................    setup_ccp1(CCP_PWM); 
*
0242:  BCF    F94.2
0244:  BCF    F8B.2
0246:  MOVLW  0C
0248:  MOVWF  FBD
....................    setup_timer_2(T2_DIV_BY_16, 200, 1); 
024A:  MOVLW  00
024C:  IORLW  06
024E:  MOVWF  FCA
0250:  MOVLW  C8
0252:  MOVWF  FCB
....................    output_low(PIN_C1); //ccp2 
0254:  BCF    F94.1
0256:  BCF    F8B.1
....................    setup_ccp2(CCP_PWM); 
0258:  BCF    F94.1
025A:  BCF    F8B.1
025C:  MOVLW  0C
025E:  MOVWF  FBA
....................    set_pwm2_duty(190);         
0260:  MOVLW  BE
0262:  MOVWF  FBB
....................    delay_ms(100); 
0264:  MOVLW  64
0266:  MOVLB  2
0268:  MOVWF  x81
026A:  MOVLB  0
026C:  RCALL  021A
....................    set_pwm2_duty(0);       
026E:  CLRF   FBB
....................    delay_ms(40); 
0270:  MOVLW  28
0272:  MOVLB  2
0274:  MOVWF  x81
0276:  MOVLB  0
0278:  RCALL  021A
....................    set_pwm2_duty(100);       
027A:  MOVLW  64
027C:  MOVWF  FBB
....................    delay_ms(100); 
027E:  MOVLB  2
0280:  MOVWF  x81
0282:  MOVLB  0
0284:  RCALL  021A
....................    set_pwm2_duty(0); 
0286:  CLRF   FBB
....................    output_low(PIN_C1); //CCP2 
0288:  BCF    F94.1
028A:  BCF    F8B.1
028C:  GOTO   1A24 (RETURN)
.................... } 
....................  
.................... void Motor1_Start() 
0290:  MOVLW  64
0292:  MOVLB  2
0294:  MOVWF  x66
.................... { 
....................    int duty = 100; 
....................  
....................    output_low(PIN_C2); //CCP1 
0296:  BCF    F94.2
0298:  BCF    F8B.2
....................    setup_ccp1(CCP_PWM); 
029A:  BCF    F94.2
029C:  BCF    F8B.2
029E:  MOVLW  0C
02A0:  MOVWF  FBD
....................    setup_timer_2(T2_DIV_BY_16, 255, 1); 
02A2:  MOVLW  00
02A4:  IORLW  06
02A6:  MOVWF  FCA
02A8:  MOVLW  FF
02AA:  MOVWF  FCB
....................    set_pwm1_duty(duty);         
02AC:  MOVFF  266,FBE
....................    delay_ms(250); 
02B0:  MOVLW  FA
02B2:  MOVWF  x81
02B4:  MOVLB  0
02B6:  RCALL  021A
....................    duty = 0; 
02B8:  MOVLB  2
02BA:  CLRF   x66
....................    set_pwm1_duty(duty);       
02BC:  MOVFF  266,FBE
....................    delay_ms(80); 
02C0:  MOVLW  50
02C2:  MOVWF  x81
02C4:  MOVLB  0
02C6:  RCALL  021A
....................    duty = 200; 
02C8:  MOVLW  C8
02CA:  MOVLB  2
02CC:  MOVWF  x66
....................    set_pwm1_duty(duty);       
02CE:  MOVFF  266,FBE
....................    delay_ms(200); 
02D2:  MOVWF  x81
02D4:  MOVLB  0
02D6:  RCALL  021A
....................    duty = 0; 
02D8:  MOVLB  2
02DA:  CLRF   x66
....................    set_pwm1_duty(duty);     
02DC:  MOVFF  266,FBE
....................    output_low(PIN_C2); //CCP1 
02E0:  BCF    F94.2
02E2:  BCF    F8B.2
02E4:  MOVLB  0
02E6:  GOTO   1A28 (RETURN)
.................... } 
....................  
.................... void If_Message(VOID) 
.................... { 
....................    char _Cel1[8], _Cel2[8]; 
....................  
....................    for (INT indexM = 0; indexM < 5; IndexM++) 
*
1690:  MOVLB  2
1692:  CLRF   x76
1694:  MOVF   x76,W
1696:  SUBLW  04
1698:  BNC   16F6
....................    { 
....................       _Cel1[indexM] = read_eeprom (indexM + 25); 
169A:  CLRF   03
169C:  MOVF   x76,W
169E:  ADDLW  66
16A0:  MOVWF  FE9
16A2:  MOVLW  02
16A4:  ADDWFC 03,W
16A6:  MOVWF  FEA
16A8:  MOVLW  19
16AA:  ADDWF  x76,W
16AC:  MOVWF  x82
16AE:  MOVFF  FF2,283
16B2:  BCF    FF2.7
16B4:  MOVFF  282,FA9
16B8:  BCF    FA6.6
16BA:  BCF    FA6.7
16BC:  BSF    FA6.0
16BE:  MOVF   FA8,W
16C0:  BTFSC  x83.7
16C2:  BSF    FF2.7
16C4:  MOVWF  FEF
....................       _Cel2[indexM] = read_eeprom (indexM + 30); 
16C6:  CLRF   03
16C8:  MOVF   x76,W
16CA:  ADDLW  6E
16CC:  MOVWF  FE9
16CE:  MOVLW  02
16D0:  ADDWFC 03,W
16D2:  MOVWF  FEA
16D4:  MOVLW  1E
16D6:  ADDWF  x76,W
16D8:  MOVWF  x82
16DA:  MOVFF  FF2,283
16DE:  BCF    FF2.7
16E0:  MOVFF  282,FA9
16E4:  BCF    FA6.6
16E6:  BCF    FA6.7
16E8:  BSF    FA6.0
16EA:  MOVF   FA8,W
16EC:  BTFSC  x83.7
16EE:  BSF    FF2.7
16F0:  MOVWF  FEF
16F2:  INCF   x76,F
16F4:  BRA    1694
....................    } 
....................  
....................    float Num1 = atof (_Cel1); 
....................    float Num2 = atof (_Cel2); 
16F6:  MOVLW  02
16F8:  MOVWF  x85
16FA:  MOVLW  66
16FC:  MOVWF  x84
16FE:  CLRF   x87
1700:  CLRF   x86
1702:  MOVLB  0
1704:  CALL   0962
1708:  MOVFF  03,27A
170C:  MOVFF  02,279
1710:  MOVFF  01,278
1714:  MOVFF  00,277
1718:  MOVLW  02
171A:  MOVLB  2
171C:  MOVWF  x85
171E:  MOVLW  6E
1720:  MOVWF  x84
1722:  CLRF   x87
1724:  CLRF   x86
1726:  MOVLB  0
1728:  CALL   0962
172C:  MOVFF  03,27E
1730:  MOVFF  02,27D
1734:  MOVFF  01,27C
1738:  MOVFF  00,27B
....................     
....................    for (int index = 1; index < 10; index++) 
173C:  MOVLW  01
173E:  MOVLB  2
1740:  MOVWF  x7F
1742:  MOVF   x7F,W
1744:  SUBLW  09
1746:  BNC   17A2
....................    { 
....................       LatRead[index - 1] = read_eeprom(index); 
1748:  MOVLW  01
174A:  SUBWF  x7F,W
174C:  CLRF   03
174E:  ADDLW  22
1750:  MOVWF  FE9
1752:  MOVLW  00
1754:  ADDWFC 03,W
1756:  MOVWF  FEA
1758:  MOVFF  FF2,282
175C:  BCF    FF2.7
175E:  MOVFF  27F,FA9
1762:  BCF    FA6.6
1764:  BCF    FA6.7
1766:  BSF    FA6.0
1768:  MOVF   FA8,W
176A:  BTFSC  x82.7
176C:  BSF    FF2.7
176E:  MOVWF  FEF
....................       LonRead[index - 1] = read_eeprom(index + 10); 
1770:  MOVLW  01
1772:  SUBWF  x7F,W
1774:  CLRF   03
1776:  ADDLW  2C
1778:  MOVWF  FE9
177A:  MOVLW  00
177C:  ADDWFC 03,W
177E:  MOVWF  FEA
1780:  MOVLW  0A
1782:  ADDWF  x7F,W
1784:  MOVWF  x82
1786:  MOVFF  FF2,283
178A:  BCF    FF2.7
178C:  MOVFF  282,FA9
1790:  BCF    FA6.6
1792:  BCF    FA6.7
1794:  BSF    FA6.0
1796:  MOVF   FA8,W
1798:  BTFSC  x83.7
179A:  BSF    FF2.7
179C:  MOVWF  FEF
179E:  INCF   x7F,F
17A0:  BRA    1742
....................    } 
....................     
....................    if (Send_Message) 
17A2:  BSF    F93.0
17A4:  BTFSS  F81.0
17A6:  BRA    18FC
....................    { 
....................       set_pwm2_duty(5);    
17A8:  MOVLW  05
17AA:  MOVWF  FBB
....................       output_high(pin_a4); 
17AC:  BCF    F92.4
17AE:  BSF    F89.4
....................       printf ("AT+CMGF=1\r") ; 
17B0:  MOVLW  9C
17B2:  MOVWF  FF6
17B4:  MOVLW  01
17B6:  MOVWF  FF7
17B8:  MOVLB  0
17BA:  BRA    149C
....................       delay_ms(10); 
17BC:  MOVLW  0A
17BE:  MOVLB  2
17C0:  MOVWF  x81
17C2:  MOVLB  0
17C4:  CALL   021A
....................       printf("AT+CMGS=\"+52%.0f%.0f\"\r",Num1,Num2); 
17C8:  MOVLW  A8
17CA:  MOVWF  FF6
17CC:  MOVLW  01
17CE:  MOVWF  FF7
17D0:  MOVLW  0C
17D2:  MOVLB  2
17D4:  MOVWF  x88
17D6:  MOVLB  0
17D8:  RCALL  14C0
17DA:  MOVLW  89
17DC:  MOVWF  FE9
17DE:  MOVFF  27A,28B
17E2:  MOVFF  279,28A
17E6:  MOVFF  278,289
17EA:  MOVFF  277,288
17EE:  MOVLB  2
17F0:  CLRF   x8C
17F2:  MOVLB  0
17F4:  RCALL  14EA
17F6:  MOVLW  89
17F8:  MOVWF  FE9
17FA:  MOVFF  27E,28B
17FE:  MOVFF  27D,28A
1802:  MOVFF  27C,289
1806:  MOVFF  27B,288
180A:  MOVLB  2
180C:  CLRF   x8C
180E:  MOVLB  0
1810:  RCALL  14EA
1812:  MOVLW  22
1814:  BTFSS  F9E.4
1816:  BRA    1814
1818:  MOVWF  FAD
181A:  MOVLW  0D
181C:  BTFSS  F9E.4
181E:  BRA    181C
1820:  MOVWF  FAD
....................       //printf("AT+CMGS=\"+52%.0f%.0f\"\r",Num1,Num2); 
....................       delay_ms(10); 
1822:  MOVLW  0A
1824:  MOVLB  2
1826:  MOVWF  x81
1828:  MOVLB  0
182A:  CALL   021A
....................       printf("https://maps.google.com/?q=%.6f,-%.6f\x1a\r",atof(LatRead),atof(LonRead)); 
182E:  MOVLB  2
1830:  CLRF   x85
1832:  MOVLW  22
1834:  MOVWF  x84
1836:  CLRF   x87
1838:  CLRF   x86
183A:  MOVLB  0
183C:  CALL   0962
1840:  MOVFF  03,283
1844:  MOVFF  02,282
1848:  MOVFF  01,281
184C:  MOVFF  00,280
1850:  MOVLB  2
1852:  CLRF   x85
1854:  MOVLW  2C
1856:  MOVWF  x84
1858:  CLRF   x87
185A:  CLRF   x86
185C:  MOVLB  0
185E:  CALL   0962
1862:  MOVFF  03,287
1866:  MOVFF  02,286
186A:  MOVFF  01,285
186E:  MOVFF  00,284
1872:  MOVLW  C0
1874:  MOVWF  FF6
1876:  MOVLW  01
1878:  MOVWF  FF7
187A:  MOVLW  1B
187C:  MOVLB  2
187E:  MOVWF  x88
1880:  MOVLB  0
1882:  RCALL  14C0
1884:  MOVLW  89
1886:  MOVWF  FE9
1888:  MOVFF  283,28B
188C:  MOVFF  282,28A
1890:  MOVFF  281,289
1894:  MOVFF  280,288
1898:  MOVLW  06
189A:  MOVLB  2
189C:  MOVWF  x8C
189E:  MOVLB  0
18A0:  RCALL  14EA
18A2:  MOVLW  2C
18A4:  BTFSS  F9E.4
18A6:  BRA    18A4
18A8:  MOVWF  FAD
18AA:  MOVLW  2D
18AC:  BTFSS  F9E.4
18AE:  BRA    18AC
18B0:  MOVWF  FAD
18B2:  MOVLW  89
18B4:  MOVWF  FE9
18B6:  MOVFF  287,28B
18BA:  MOVFF  286,28A
18BE:  MOVFF  285,289
18C2:  MOVFF  284,288
18C6:  MOVLW  06
18C8:  MOVLB  2
18CA:  MOVWF  x8C
18CC:  MOVLB  0
18CE:  RCALL  14EA
18D0:  MOVLW  1A
18D2:  BTFSS  F9E.4
18D4:  BRA    18D2
18D6:  MOVWF  FAD
18D8:  MOVLW  0D
18DA:  BTFSS  F9E.4
18DC:  BRA    18DA
18DE:  MOVWF  FAD
....................       delay_ms(1500); 
18E0:  MOVLW  06
18E2:  MOVLB  2
18E4:  MOVWF  x80
18E6:  MOVLW  FA
18E8:  MOVWF  x81
18EA:  MOVLB  0
18EC:  CALL   021A
18F0:  MOVLB  2
18F2:  DECFSZ x80,F
18F4:  BRA    18E6
....................       set_pwm2_duty(0); 
18F6:  CLRF   FBB
....................       output_low(pin_a4); 
18F8:  BCF    F92.4
18FA:  BCF    F89.4
....................    } 
18FC:  MOVLB  0
18FE:  GOTO   1A70 (RETURN)
.................... } 
....................  
.................... void process_tel_number() 
.................... { 
....................    if(1 == str_flag2) 
1902:  MOVLB  2
1904:  DECFSZ x5C,W
1906:  BRA    19AE
....................    { 
....................       if(str[1]=='@') 
1908:  MOVF   5D,W
190A:  SUBLW  40
190C:  BNZ   19AE
....................             { 
....................                set_pwm2_duty(150); // Beep when a telephone number is configured 
190E:  MOVLW  96
1910:  MOVWF  FBB
....................                delay_ms(40); 
1912:  MOVLW  28
1914:  MOVWF  x81
1916:  MOVLB  0
1918:  CALL   021A
....................                set_pwm2_duty(0);   // End beep 
191C:  CLRF   FBB
....................                delay_ms(40); 
191E:  MOVLW  28
1920:  MOVLB  2
1922:  MOVWF  x81
1924:  MOVLB  0
1926:  CALL   021A
....................                set_pwm2_duty(150); // Beep when a telephone number is configured 
192A:  MOVLW  96
192C:  MOVWF  FBB
....................                delay_ms(40); 
192E:  MOVLW  28
1930:  MOVLB  2
1932:  MOVWF  x81
1934:  MOVLB  0
1936:  CALL   021A
....................                set_pwm2_duty(0);   // End beep 
193A:  CLRF   FBB
....................                delay_ms(40); 
193C:  MOVLW  28
193E:  MOVLB  2
1940:  MOVWF  x81
1942:  MOVLB  0
1944:  CALL   021A
....................                set_pwm2_duty(150); // Beep when a telephone number is configured 
1948:  MOVLW  96
194A:  MOVWF  FBB
....................                delay_ms(40); 
194C:  MOVLW  28
194E:  MOVLB  2
1950:  MOVWF  x81
1952:  MOVLB  0
1954:  CALL   021A
....................                set_pwm2_duty(0);   // End beep 
1958:  CLRF   FBB
....................                for(int index = 0; index < 10; index++) 
195A:  MOVLB  2
195C:  CLRF   x66
195E:  MOVF   x66,W
1960:  SUBLW  09
1962:  BNC   19AE
....................                { 
....................                    write_eeprom(index + 25, str[index + 2]); 
1964:  MOVLW  19
1966:  ADDWF  x66,W
1968:  MOVWF  x67
196A:  MOVLW  02
196C:  ADDWF  x66,W
196E:  CLRF   03
1970:  ADDLW  5C
1972:  MOVWF  FE9
1974:  MOVLW  00
1976:  ADDWFC 03,W
1978:  MOVWF  FEA
197A:  MOVFF  FEF,268
197E:  MOVF   FF2,W
1980:  MOVWF  00
1982:  BCF    FF2.7
1984:  MOVFF  267,FA9
1988:  MOVFF  268,FA8
198C:  BCF    FA6.6
198E:  BCF    FA6.7
1990:  BSF    FA6.2
1992:  MOVLB  F
1994:  MOVLW  55
1996:  MOVWF  FA7
1998:  MOVLW  AA
199A:  MOVWF  FA7
199C:  BSF    FA6.1
199E:  BTFSC  FA6.1
19A0:  BRA    199E
19A2:  BCF    FA6.2
19A4:  MOVF   00,W
19A6:  IORWF  FF2,F
19A8:  MOVLB  2
19AA:  INCF   x66,F
19AC:  BRA    195E
....................                } 
....................             } 
....................    } 
....................    str_flag2 = 0; 
19AE:  CLRF   x5C
19B0:  MOVLB  0
19B2:  GOTO   1A72 (RETURN)
.................... } 
....................  
.................... void Get_GPS(void) 
.................... { 
....................    char lat[9], lg[10]; 
....................  
....................    if ( (str_flag == 1 ) && (savePosition == 1) ) 
*
0BAE:  MOVLB  2
0BB0:  DECFSZ x5A,W
0BB2:  BRA    0C86
0BB4:  DECFSZ 36,W
0BB6:  BRA    0C86
....................    { 
....................       ///////////////////// Si el str[4] == G obtenemos de la trama los valores de la latitud 
....................       if (str[4] == 'G') 
0BB8:  MOVLB  0
0BBA:  MOVF   x60,W
0BBC:  SUBLW  47
0BBE:  BNZ   0C20
....................       { 
....................          for (INT index = 0; index < 9; index++) 
0BC0:  MOVLB  2
0BC2:  CLRF   x79
0BC4:  MOVF   x79,W
0BC6:  SUBLW  08
0BC8:  BNC   0BFE
....................          { 
....................             lat[index] = str[index + 18]; 
0BCA:  CLRF   03
0BCC:  MOVF   x79,W
0BCE:  ADDLW  66
0BD0:  MOVWF  01
0BD2:  MOVLW  02
0BD4:  ADDWFC 03,F
0BD6:  MOVFF  03,27C
0BDA:  MOVLW  12
0BDC:  ADDWF  x79,W
0BDE:  CLRF   03
0BE0:  ADDLW  5C
0BE2:  MOVWF  FE9
0BE4:  MOVLW  00
0BE6:  ADDWFC 03,W
0BE8:  MOVWF  FEA
0BEA:  MOVFF  FEF,27D
0BEE:  MOVFF  27C,FEA
0BF2:  MOVFF  01,FE9
0BF6:  MOVFF  27D,FEF
0BFA:  INCF   x79,F
0BFC:  BRA    0BC4
....................          } 
....................  
....................          latitud = atof (lat); 
0BFE:  MOVLW  02
0C00:  MOVWF  x85
0C02:  MOVLW  66
0C04:  MOVWF  x84
0C06:  CLRF   x87
0C08:  CLRF   x86
0C0A:  MOVLB  0
0C0C:  RCALL  0962
0C0E:  MOVFF  03,3B
0C12:  MOVFF  02,3A
0C16:  MOVFF  01,39
0C1A:  MOVFF  00,38
....................         // output_toggle (pin_a4); 
....................       } 
0C1E:  BRA    0C84
....................  
....................       /////////////////// Cuando str[4] = M obtenemos de la trama los valores de longitud en string 
....................       else if (str[4] == 'M') 
0C20:  MOVF   x60,W
0C22:  SUBLW  4D
0C24:  BNZ   0C84
....................       { 
....................          for (INT index = 0; index < 10; index++) 
0C26:  MOVLB  2
0C28:  CLRF   x7A
0C2A:  MOVF   x7A,W
0C2C:  SUBLW  09
0C2E:  BNC   0C64
....................          { 
....................             lg[index] = str[index + 32]; 
0C30:  CLRF   03
0C32:  MOVF   x7A,W
0C34:  ADDLW  6F
0C36:  MOVWF  01
0C38:  MOVLW  02
0C3A:  ADDWFC 03,F
0C3C:  MOVFF  03,27C
0C40:  MOVLW  20
0C42:  ADDWF  x7A,W
0C44:  CLRF   03
0C46:  ADDLW  5C
0C48:  MOVWF  FE9
0C4A:  MOVLW  00
0C4C:  ADDWFC 03,W
0C4E:  MOVWF  FEA
0C50:  MOVFF  FEF,27D
0C54:  MOVFF  27C,FEA
0C58:  MOVFF  01,FE9
0C5C:  MOVFF  27D,FEF
0C60:  INCF   x7A,F
0C62:  BRA    0C2A
....................          } 
....................  
....................          longitud = atof (lg); 
0C64:  MOVLW  02
0C66:  MOVWF  x85
0C68:  MOVLW  6F
0C6A:  MOVWF  x84
0C6C:  CLRF   x87
0C6E:  CLRF   x86
0C70:  MOVLB  0
0C72:  RCALL  0962
0C74:  MOVFF  03,3F
0C78:  MOVFF  02,3E
0C7C:  MOVFF  01,3D
0C80:  MOVFF  00,3C
0C84:  MOVLB  2
....................       } 
....................    } 
....................  
....................    str_flag = 0; 
0C86:  CLRF   x5A
0C88:  MOVLB  0
0C8A:  GOTO   1A6A (RETURN)
.................... } 
....................  
.................... void gps_info_processor(void) 
.................... { 
....................    // Alert that GPS is Connected/Disconnected 
....................       // NOTE: Change set_pwm1_duty to set_pwm2_duty when buzzer works properly 
....................       if( (latitud > 0.5) && (GPS_Connected == 0) ) 
*
0FA6:  MOVLB  2
0FA8:  CLRF   x6A
0FAA:  CLRF   x69
0FAC:  CLRF   x68
0FAE:  MOVLW  7E
0FB0:  MOVWF  x67
0FB2:  MOVFF  3B,26E
0FB6:  MOVFF  3A,26D
0FBA:  MOVFF  39,26C
0FBE:  MOVFF  38,26B
0FC2:  MOVLB  0
0FC4:  RCALL  0C8E
0FC6:  BNC   1020
0FC8:  MOVF   37,F
0FCA:  BNZ   1020
....................       { 
....................         //GPS Connected 
....................         set_pwm2_duty(130);         
0FCC:  MOVLW  82
0FCE:  MOVWF  FBB
....................         delay_ms(100); 
0FD0:  MOVLW  64
0FD2:  MOVLB  2
0FD4:  MOVWF  x81
0FD6:  MOVLB  0
0FD8:  CALL   021A
....................         set_pwm2_duty(0);  
0FDC:  CLRF   FBB
....................         delay_ms(20); 
0FDE:  MOVLW  14
0FE0:  MOVLB  2
0FE2:  MOVWF  x81
0FE4:  MOVLB  0
0FE6:  CALL   021A
....................         set_pwm2_duty(130);         
0FEA:  MOVLW  82
0FEC:  MOVWF  FBB
....................         delay_ms(100); 
0FEE:  MOVLW  64
0FF0:  MOVLB  2
0FF2:  MOVWF  x81
0FF4:  MOVLB  0
0FF6:  CALL   021A
....................         set_pwm2_duty(0);  
0FFA:  CLRF   FBB
....................         delay_ms(20); 
0FFC:  MOVLW  14
0FFE:  MOVLB  2
1000:  MOVWF  x81
1002:  MOVLB  0
1004:  CALL   021A
....................         set_pwm2_duty(130);         
1008:  MOVLW  82
100A:  MOVWF  FBB
....................         delay_ms(100); 
100C:  MOVLW  64
100E:  MOVLB  2
1010:  MOVWF  x81
1012:  MOVLB  0
1014:  CALL   021A
....................         set_pwm2_duty(0);  
1018:  CLRF   FBB
....................         GPS_Connected = 1; 
101A:  MOVLW  01
101C:  MOVWF  37
....................       } 
101E:  BRA    1066
....................       else if( (latitud < 0.5) && (GPS_Connected == 1) ) 
1020:  MOVFF  3B,26A
1024:  MOVFF  3A,269
1028:  MOVFF  39,268
102C:  MOVFF  38,267
1030:  MOVLB  2
1032:  CLRF   x6E
1034:  CLRF   x6D
1036:  CLRF   x6C
1038:  MOVLW  7E
103A:  MOVWF  x6B
103C:  MOVLB  0
103E:  RCALL  0C8E
1040:  BNC   1066
1042:  DECFSZ 37,W
1044:  BRA    1066
....................       { 
....................       //GPS Disconnected 
....................         set_pwm2_duty(80);         
1046:  MOVLW  50
1048:  MOVWF  FBB
....................         delay_ms(500); 
104A:  MOVLW  02
104C:  MOVLB  2
104E:  MOVWF  x67
1050:  MOVLW  FA
1052:  MOVWF  x81
1054:  MOVLB  0
1056:  CALL   021A
105A:  MOVLB  2
105C:  DECFSZ x67,F
105E:  BRA    1050
....................         set_pwm2_duty(0); 
1060:  CLRF   FBB
....................         GPS_Connected = 0; 
1062:  CLRF   37
1064:  MOVLB  0
....................       } 
....................        
....................       // First store position into eeprom memory every 10 seconds 
....................       if( (savePosition == 1) && (GPS_Connected == 1) ) 
1066:  DECFSZ 36,W
1068:  BRA    1496
106A:  DECFSZ 37,W
106C:  BRA    1496
....................       { 
....................          // sprintf(LatWrite,"%.6f",latitud*0.01); 
....................          // sprintf(LonWrite,"%.6f",longitud*0.01); 
....................          latitudConverted  = (float) ( (int8) (latitud * 0.01)  + (float) (((latitud * 0.01)  - (int8) (latitud * 0.01))  / 60.0)*100 ); 
106E:  MOVFF  3B,298
1072:  MOVFF  3A,297
1076:  MOVFF  39,296
107A:  MOVFF  38,295
107E:  MOVLW  0A
1080:  MOVLB  2
1082:  MOVWF  x9C
1084:  MOVLW  D7
1086:  MOVWF  x9B
1088:  MOVLW  23
108A:  MOVWF  x9A
108C:  MOVLW  78
108E:  MOVWF  x99
1090:  MOVLB  0
1092:  CALL   0320
1096:  MOVFF  03,26F
109A:  MOVFF  02,26E
109E:  MOVFF  01,26D
10A2:  MOVFF  00,26C
10A6:  CALL   068E
10AA:  MOVFF  01,267
10AE:  MOVFF  3B,298
10B2:  MOVFF  3A,297
10B6:  MOVFF  39,296
10BA:  MOVFF  38,295
10BE:  MOVLW  0A
10C0:  MOVLB  2
10C2:  MOVWF  x9C
10C4:  MOVLW  D7
10C6:  MOVWF  x9B
10C8:  MOVLW  23
10CA:  MOVWF  x9A
10CC:  MOVLW  78
10CE:  MOVWF  x99
10D0:  MOVLB  0
10D2:  CALL   0320
10D6:  MOVFF  03,26B
10DA:  MOVFF  02,26A
10DE:  MOVFF  01,269
10E2:  MOVFF  00,268
10E6:  MOVFF  3B,298
10EA:  MOVFF  3A,297
10EE:  MOVFF  39,296
10F2:  MOVFF  38,295
10F6:  MOVLW  0A
10F8:  MOVLB  2
10FA:  MOVWF  x9C
10FC:  MOVLW  D7
10FE:  MOVWF  x9B
1100:  MOVLW  23
1102:  MOVWF  x9A
1104:  MOVLW  78
1106:  MOVWF  x99
1108:  MOVLB  0
110A:  CALL   0320
110E:  MOVFF  03,26F
1112:  MOVFF  02,26E
1116:  MOVFF  01,26D
111A:  MOVFF  00,26C
111E:  CALL   068E
1122:  MOVLB  2
1124:  CLRF   x98
1126:  MOVFF  01,297
112A:  MOVLB  0
112C:  CALL   02EA
1130:  BSF    FD8.1
1132:  MOVFF  26B,29A
1136:  MOVFF  26A,299
113A:  MOVFF  269,298
113E:  MOVFF  268,297
1142:  MOVFF  03,29E
1146:  MOVFF  02,29D
114A:  MOVFF  01,29C
114E:  MOVFF  00,29B
1152:  CALL   0416
1156:  MOVFF  03,26B
115A:  MOVFF  02,26A
115E:  MOVFF  01,269
1162:  MOVFF  00,268
1166:  MOVFF  03,29A
116A:  MOVFF  02,299
116E:  MOVFF  01,298
1172:  MOVFF  00,297
1176:  MOVLB  2
1178:  CLRF   x9E
117A:  CLRF   x9D
117C:  MOVLW  70
117E:  MOVWF  x9C
1180:  MOVLW  84
1182:  MOVWF  x9B
1184:  MOVLB  0
1186:  CALL   06CA
118A:  MOVFF  03,26B
118E:  MOVFF  02,26A
1192:  MOVFF  01,269
1196:  MOVFF  00,268
119A:  MOVFF  03,298
119E:  MOVFF  02,297
11A2:  MOVFF  01,296
11A6:  MOVFF  00,295
11AA:  MOVLB  2
11AC:  CLRF   x9C
11AE:  CLRF   x9B
11B0:  MOVLW  48
11B2:  MOVWF  x9A
11B4:  MOVLW  85
11B6:  MOVWF  x99
11B8:  MOVLB  0
11BA:  CALL   0320
11BE:  MOVFF  03,26B
11C2:  MOVFF  02,26A
11C6:  MOVFF  01,269
11CA:  MOVFF  00,268
11CE:  MOVLB  2
11D0:  CLRF   x98
11D2:  MOVFF  267,297
11D6:  MOVLB  0
11D8:  CALL   02EA
11DC:  BCF    FD8.1
11DE:  MOVFF  03,29A
11E2:  MOVFF  02,299
11E6:  MOVFF  01,298
11EA:  MOVFF  00,297
11EE:  MOVFF  26B,29E
11F2:  MOVFF  26A,29D
11F6:  MOVFF  269,29C
11FA:  MOVFF  268,29B
11FE:  CALL   0416
1202:  MOVFF  03,57
1206:  MOVFF  02,56
120A:  MOVFF  01,55
120E:  MOVFF  00,54
....................          longitudConverted = (float) ( (int8) (longitud * 0.01) + (float) (((longitud * 0.01) - (int8) (longitud * 0.01)) / 60.0)*100 ); 
1212:  MOVFF  3F,298
1216:  MOVFF  3E,297
121A:  MOVFF  3D,296
121E:  MOVFF  3C,295
1222:  MOVLW  0A
1224:  MOVLB  2
1226:  MOVWF  x9C
1228:  MOVLW  D7
122A:  MOVWF  x9B
122C:  MOVLW  23
122E:  MOVWF  x9A
1230:  MOVLW  78
1232:  MOVWF  x99
1234:  MOVLB  0
1236:  CALL   0320
123A:  MOVFF  03,26F
123E:  MOVFF  02,26E
1242:  MOVFF  01,26D
1246:  MOVFF  00,26C
124A:  CALL   068E
124E:  MOVFF  01,267
1252:  MOVFF  3F,298
1256:  MOVFF  3E,297
125A:  MOVFF  3D,296
125E:  MOVFF  3C,295
1262:  MOVLW  0A
1264:  MOVLB  2
1266:  MOVWF  x9C
1268:  MOVLW  D7
126A:  MOVWF  x9B
126C:  MOVLW  23
126E:  MOVWF  x9A
1270:  MOVLW  78
1272:  MOVWF  x99
1274:  MOVLB  0
1276:  CALL   0320
127A:  MOVFF  03,26B
127E:  MOVFF  02,26A
1282:  MOVFF  01,269
1286:  MOVFF  00,268
128A:  MOVFF  3F,298
128E:  MOVFF  3E,297
1292:  MOVFF  3D,296
1296:  MOVFF  3C,295
129A:  MOVLW  0A
129C:  MOVLB  2
129E:  MOVWF  x9C
12A0:  MOVLW  D7
12A2:  MOVWF  x9B
12A4:  MOVLW  23
12A6:  MOVWF  x9A
12A8:  MOVLW  78
12AA:  MOVWF  x99
12AC:  MOVLB  0
12AE:  CALL   0320
12B2:  MOVFF  03,26F
12B6:  MOVFF  02,26E
12BA:  MOVFF  01,26D
12BE:  MOVFF  00,26C
12C2:  CALL   068E
12C6:  MOVLB  2
12C8:  CLRF   x98
12CA:  MOVFF  01,297
12CE:  MOVLB  0
12D0:  CALL   02EA
12D4:  BSF    FD8.1
12D6:  MOVFF  26B,29A
12DA:  MOVFF  26A,299
12DE:  MOVFF  269,298
12E2:  MOVFF  268,297
12E6:  MOVFF  03,29E
12EA:  MOVFF  02,29D
12EE:  MOVFF  01,29C
12F2:  MOVFF  00,29B
12F6:  CALL   0416
12FA:  MOVFF  03,26B
12FE:  MOVFF  02,26A
1302:  MOVFF  01,269
1306:  MOVFF  00,268
130A:  MOVFF  03,29A
130E:  MOVFF  02,299
1312:  MOVFF  01,298
1316:  MOVFF  00,297
131A:  MOVLB  2
131C:  CLRF   x9E
131E:  CLRF   x9D
1320:  MOVLW  70
1322:  MOVWF  x9C
1324:  MOVLW  84
1326:  MOVWF  x9B
1328:  MOVLB  0
132A:  CALL   06CA
132E:  MOVFF  03,26B
1332:  MOVFF  02,26A
1336:  MOVFF  01,269
133A:  MOVFF  00,268
133E:  MOVFF  03,298
1342:  MOVFF  02,297
1346:  MOVFF  01,296
134A:  MOVFF  00,295
134E:  MOVLB  2
1350:  CLRF   x9C
1352:  CLRF   x9B
1354:  MOVLW  48
1356:  MOVWF  x9A
1358:  MOVLW  85
135A:  MOVWF  x99
135C:  MOVLB  0
135E:  CALL   0320
1362:  MOVFF  03,26B
1366:  MOVFF  02,26A
136A:  MOVFF  01,269
136E:  MOVFF  00,268
1372:  MOVLB  2
1374:  CLRF   x98
1376:  MOVFF  267,297
137A:  MOVLB  0
137C:  CALL   02EA
1380:  BCF    FD8.1
1382:  MOVFF  03,29A
1386:  MOVFF  02,299
138A:  MOVFF  01,298
138E:  MOVFF  00,297
1392:  MOVFF  26B,29E
1396:  MOVFF  26A,29D
139A:  MOVFF  269,29C
139E:  MOVFF  268,29B
13A2:  CALL   0416
13A6:  MOVFF  03,5B
13AA:  MOVFF  02,5A
13AE:  MOVFF  01,59
13B2:  MOVFF  00,58
....................          sprintf(LatWrite,"%.6f", latitudConverted); 
13B6:  MOVLB  2
13B8:  CLRF   x63
13BA:  MOVLW  40
13BC:  MOVWF  x62
13BE:  MOVLW  89
13C0:  MOVWF  FE9
13C2:  MOVFF  57,26A
13C6:  MOVFF  56,269
13CA:  MOVFF  55,268
13CE:  MOVFF  54,267
13D2:  MOVLW  06
13D4:  MOVWF  x6B
13D6:  MOVLB  0
13D8:  RCALL  0DFE
....................          sprintf(LonWrite,"%.6f", longitudConverted); 
13DA:  MOVLB  2
13DC:  CLRF   x63
13DE:  MOVLW  4A
13E0:  MOVWF  x62
13E2:  MOVLW  89
13E4:  MOVWF  FE9
13E6:  MOVFF  5B,26A
13EA:  MOVFF  5A,269
13EE:  MOVFF  59,268
13F2:  MOVFF  58,267
13F6:  MOVLW  06
13F8:  MOVWF  x6B
13FA:  MOVLB  0
13FC:  RCALL  0DFE
....................          for(int index = 1; index < 10; index++) 
13FE:  MOVLW  01
1400:  MOVLB  2
1402:  MOVWF  x66
1404:  MOVF   x66,W
1406:  SUBLW  09
1408:  BNC   1494
....................          { 
....................             write_eeprom(index, LatWrite[index - 1]); 
140A:  MOVLW  01
140C:  SUBWF  x66,W
140E:  CLRF   03
1410:  ADDLW  40
1412:  MOVWF  FE9
1414:  MOVLW  00
1416:  ADDWFC 03,W
1418:  MOVWF  FEA
141A:  MOVFF  FEF,267
141E:  MOVF   FF2,W
1420:  MOVWF  00
1422:  BCF    FF2.7
1424:  MOVFF  266,FA9
1428:  MOVFF  267,FA8
142C:  BCF    FA6.6
142E:  BCF    FA6.7
1430:  BSF    FA6.2
1432:  MOVLB  F
1434:  MOVLW  55
1436:  MOVWF  FA7
1438:  MOVLW  AA
143A:  MOVWF  FA7
143C:  BSF    FA6.1
143E:  BTFSC  FA6.1
1440:  BRA    143E
1442:  BCF    FA6.2
1444:  MOVF   00,W
1446:  IORWF  FF2,F
....................             write_eeprom(index + 10, LonWrite[index - 1]); 
1448:  MOVLW  0A
144A:  MOVLB  2
144C:  ADDWF  x66,W
144E:  MOVWF  x67
1450:  MOVLW  01
1452:  SUBWF  x66,W
1454:  CLRF   03
1456:  ADDLW  4A
1458:  MOVWF  FE9
145A:  MOVLW  00
145C:  ADDWFC 03,W
145E:  MOVWF  FEA
1460:  MOVFF  FEF,268
1464:  MOVF   FF2,W
1466:  MOVWF  00
1468:  BCF    FF2.7
146A:  MOVFF  267,FA9
146E:  MOVFF  268,FA8
1472:  BCF    FA6.6
1474:  BCF    FA6.7
1476:  BSF    FA6.2
1478:  MOVLB  F
147A:  MOVLW  55
147C:  MOVWF  FA7
147E:  MOVLW  AA
1480:  MOVWF  FA7
1482:  BSF    FA6.1
1484:  BTFSC  FA6.1
1486:  BRA    1484
1488:  BCF    FA6.2
148A:  MOVF   00,W
148C:  IORWF  FF2,F
148E:  MOVLB  2
1490:  INCF   x66,F
1492:  BRA    1404
....................          } 
....................          savePosition = 0; 
1494:  CLRF   36
1496:  MOVLB  0
....................       } 
1498:  GOTO   1A6E (RETURN)
.................... } 
....................  
.................... void dummyFunction(char characterRecived) 
.................... { 
....................    if (characterRecived == '$') 
*
00E6:  MOVLB  2
00E8:  MOVF   xA8,W
00EA:  SUBLW  24
00EC:  BNZ   00F4
....................    { 
....................       i = 0; 
00EE:  CLRF   x5D
....................       flag_buf = 1; 
00F0:  MOVLW  01
00F2:  MOVWF  x5B
....................    } 
....................  
....................    if (characterRecived == '<') 
00F4:  MOVF   xA8,W
00F6:  SUBLW  3C
00F8:  BNZ   0100
....................    { 
....................       i = 0; 
00FA:  CLRF   x5D
....................       flag_buf = 2; 
00FC:  MOVLW  02
00FE:  MOVWF  x5B
....................    } 
....................  
....................    if (flag_buf == 1) 
0100:  DECFSZ x5B,W
0102:  BRA    013E
....................    { 
....................       //recibimos un entero sin signo 
....................       if (characterRecived == 0x0d) 
0104:  MOVF   xA8,W
0106:  SUBLW  0D
0108:  BNZ   012A
....................       { 
....................          //si recibe un enter --- o un salto de linea 
....................          flag_buf = 0; 
010A:  CLRF   x5B
....................          str_flag = 1; //flag must be cleared by software 
010C:  MOVLW  01
010E:  MOVWF  x5A
....................          characterRecived = 0; //fin de la trama 
0110:  CLRF   xA8
....................          strcpy (str, buf); //copia en str lo que est en bufer 
0112:  CLRF   FEA
0114:  MOVLW  5C
0116:  MOVWF  FE9
0118:  MOVLW  01
011A:  MOVWF  FE2
011C:  MOVLW  5B
011E:  MOVWF  FE1
0120:  MOVF   FE7,F
0122:  MOVFF  FE6,FEE
0126:  BNZ   0120
....................       } 
0128:  BRA    013E
....................  
....................       else 
....................       { 
....................          buf[i] = characterRecived; 
012A:  CLRF   03
012C:  MOVF   x5D,W
012E:  ADDLW  5B
0130:  MOVWF  FE9
0132:  MOVLW  01
0134:  ADDWFC 03,W
0136:  MOVWF  FEA
0138:  MOVFF  2A8,FEF
....................          i++; 
013C:  INCF   x5D,F
....................       } 
....................    } 
....................  
....................    if (flag_buf == 2) 
013E:  MOVF   x5B,W
0140:  SUBLW  02
0142:  BNZ   017E
....................    { 
....................       if (characterRecived == '>') 
0144:  MOVF   xA8,W
0146:  SUBLW  3E
0148:  BNZ   016A
....................       { 
....................          flag_buf = 0; 
014A:  CLRF   x5B
....................          str_flag2 = 1; //flag must be cleared by software 
014C:  MOVLW  01
014E:  MOVWF  x5C
....................          characterRecived = 0; //fin de la trama 
0150:  CLRF   xA8
....................          strcpy (str, buf) ; 
0152:  CLRF   FEA
0154:  MOVLW  5C
0156:  MOVWF  FE9
0158:  MOVLW  01
015A:  MOVWF  FE2
015C:  MOVLW  5B
015E:  MOVWF  FE1
0160:  MOVF   FE7,F
0162:  MOVFF  FE6,FEE
0166:  BNZ   0160
....................       } 
0168:  BRA    017E
....................  
....................       else 
....................       { 
....................          buf[i] = characterRecived; 
016A:  CLRF   03
016C:  MOVF   x5D,W
016E:  ADDLW  5B
0170:  MOVWF  FE9
0172:  MOVLW  01
0174:  ADDWFC 03,W
0176:  MOVWF  FEA
0178:  MOVFF  2A8,FEF
....................          i++; 
017C:  INCF   x5D,F
....................       } 
....................    } 
017E:  MOVLB  0
0180:  GOTO   0196 (RETURN)
.................... } 
....................  
.................... int16 AdcReadAndProcessing() 
*
0828:  MOVLB  2
082A:  CLRF   x67
082C:  CLRF   x66
082E:  CLRF   x69
0830:  CLRF   x68
0832:  CLRF   x6B
0834:  CLRF   x6A
.................... { 
....................    int16 data_adc0 = 0, mmDistance = 0, distancePower = 0;  
....................  
....................    delay_us(20); 
0836:  MOVLW  0C
0838:  MOVWF  00
083A:  DECFSZ 00,F
083C:  BRA    083A
083E:  BRA    0840
0840:  NOP   
....................  
....................    data_adc0  = read_adc();     // 0 - 1024 bits 
0842:  BSF    FC2.1
0844:  BTFSC  FC2.1
0846:  BRA    0844
0848:  MOVFF  FC3,266
084C:  MOVFF  FC4,267
....................     
....................    if(data_adc0 > DISTANCE_LIMIT) 
0850:  MOVF   x67,W
0852:  SUBLW  01
0854:  BC    0866
0856:  XORLW  FF
0858:  BNZ   0860
085A:  MOVF   x66,W
085C:  SUBLW  00
085E:  BC    0866
....................    { 
....................       data_adc0 = DISTANCE_LIMIT; 
0860:  MOVLW  02
0862:  MOVWF  x67
0864:  CLRF   x66
....................    } 
....................     
....................    mmDistance = 7680 - ((data_adc0*2) * 5.0); // 0 - 2500mm 
0866:  BCF    FD8.0
0868:  RLCF   x66,W
086A:  MOVWF  x6C
086C:  RLCF   x67,W
086E:  MOVWF  x6D
0870:  MOVWF  x98
0872:  MOVFF  26C,297
0876:  MOVLB  0
0878:  RCALL  02EA
087A:  MOVFF  03,298
087E:  MOVFF  02,297
0882:  MOVFF  01,296
0886:  MOVFF  00,295
088A:  MOVLB  2
088C:  CLRF   x9C
088E:  CLRF   x9B
0890:  MOVLW  20
0892:  MOVWF  x9A
0894:  MOVLW  81
0896:  MOVWF  x99
0898:  MOVLB  0
089A:  RCALL  0320
089C:  BSF    FD8.1
089E:  MOVLB  2
08A0:  CLRF   x9A
08A2:  CLRF   x99
08A4:  MOVLW  70
08A6:  MOVWF  x98
08A8:  MOVLW  8B
08AA:  MOVWF  x97
08AC:  MOVFF  03,29E
08B0:  MOVFF  02,29D
08B4:  MOVFF  01,29C
08B8:  MOVFF  00,29B
08BC:  MOVLB  0
08BE:  RCALL  0416
08C0:  MOVFF  03,26F
08C4:  MOVFF  02,26E
08C8:  MOVFF  01,26D
08CC:  MOVFF  00,26C
08D0:  RCALL  068E
08D2:  MOVFF  02,269
08D6:  MOVFF  01,268
....................  
....................    voltage    = (mmDistance/(1000.0));  // convert distance to voltage, the higher the distance, the higher the voltage. 
08DA:  MOVFF  269,298
08DE:  MOVFF  268,297
08E2:  RCALL  02EA
08E4:  MOVFF  03,29A
08E8:  MOVFF  02,299
08EC:  MOVFF  01,298
08F0:  MOVFF  00,297
08F4:  MOVLB  2
08F6:  CLRF   x9E
08F8:  CLRF   x9D
08FA:  MOVLW  7A
08FC:  MOVWF  x9C
08FE:  MOVLW  88
0900:  MOVWF  x9B
0902:  MOVLB  0
0904:  RCALL  06CA
0906:  MOVFF  03,261
090A:  MOVFF  02,260
090E:  MOVFF  01,25F
0912:  MOVFF  00,25E
....................                                           // *2 due to we want the volteage to reach up to 5 volts 
....................     
....................    distancePower = (int16)(voltage * 49); 
0916:  MOVFF  261,298
091A:  MOVFF  260,297
091E:  MOVFF  25F,296
0922:  MOVFF  25E,295
0926:  MOVLB  2
0928:  CLRF   x9C
092A:  CLRF   x9B
092C:  MOVLW  44
092E:  MOVWF  x9A
0930:  MOVLW  84
0932:  MOVWF  x99
0934:  MOVLB  0
0936:  RCALL  0320
0938:  MOVFF  03,26F
093C:  MOVFF  02,26E
0940:  MOVFF  01,26D
0944:  MOVFF  00,26C
0948:  RCALL  068E
094A:  MOVFF  02,26B
094E:  MOVFF  01,26A
....................  
....................    return(distancePower); 
0952:  MOVLB  2
0954:  MOVFF  26A,01
0958:  MOVFF  26B,02
095C:  MOVLB  0
095E:  GOTO   1A38 (RETURN)
.................... } 

Configuration Fuses:
   Word  1: CF3F   PLL12 CPUDIV4 USBDIV FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
